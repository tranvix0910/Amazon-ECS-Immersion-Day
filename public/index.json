[
{
	"uri": "http://localhost:1313/7-networking/7.1-network_mode/",
	"title": "Amazon ECS Network Mode",
	"tags": [],
	"description": "",
	"content": "When running containers, it is very important to consider the network configuration of containers running on the host. Please refer to AWS Documentation for more information on how to choose the appropriate network mode.\nIn this section, we will have an overview of AWSVPC Mode network configuration for Amazon ECS on Fargate.\nIn AWSVPC Mode, Amazon ECS will create and manage an Elastic Network Interface (ENI) for each task, and each task will receive a separate private IP address in the VPC. This configuration provides high flexibility, allowing detailed control (granular level) of communication between tasks and services.\nAWSVPC Network Mode is supported for Amazon ECS tasks running on both Amazon EC2 and Fargate. Refer to AWS Documentation for more details.\nWhen using Amazon ECS on Fargate, AWSVPC Network Mode is required.\nReview Network Mode Open Amazon ECS console to check services.\nHere, you can select the first running task. Scroll down to the Configuration section to review the following information:\nNetwork mode\nENI ID\nPrivate IP attached to task\nYou can get Task information using AWS CLI:\naws ecs describe-tasks \\ --cluster retail-store-ecs-cluster \\ --tasks $(aws ecs list-tasks --cluster retail-store-ecs-cluster --service ui --query \u0026#39;taskArns[0]\u0026#39; --output text) Result:\n{ \u0026#34;tasks\u0026#34;: [ { \u0026#34;attachments\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;464044b3-626f-44da-86ec-fa20a064d408\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;ElasticNetworkInterface\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;ATTACHED\u0026#34;, \u0026#34;details\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;subnetId\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;subnet-08c4050330714ed3d\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;networkInterfaceId\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;eni-0a6c55131166f85c8\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;macAddress\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;06:39:15:1c:ae:1f\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;privateDnsName\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;ip-10-0-4-128.us-west-2.compute.internal\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;privateIPv4Address\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;10.0.4.128\u0026#34; } ] } ], \u0026#34;attributes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;ecs.cpu-architecture\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;x86_64\u0026#34; } ], \u0026#34;availabilityZone\u0026#34;: \u0026#34;us-west-2b\u0026#34;, \u0026#34;clusterArn\u0026#34;: \u0026#34;arn:aws:ecs:us-west-2:XXXXXXXXXX:cluster/retail-store-ecs-cluster\u0026#34;, \u0026#34;connectivity\u0026#34;: \u0026#34;CONNECTED\u0026#34;, \u0026#34;connectivityAt\u0026#34;: \u0026#34;2024-04-10T08:09:33.968000+00:00\u0026#34;, \u0026#34;containers\u0026#34;: [ { \u0026#34;containerArn\u0026#34;: \u0026#34;arn:aws:ecs:us-west-2:XXXXXXXXXX:container/retail-store-ecs-cluster/70137dd0c1d14cf982e5a6b7446c5f54/db0fa651-1727-4215-b5a5-8a5577120942\u0026#34;, \u0026#34;taskArn\u0026#34;: \u0026#34;arn:aws:ecs:us-west-2:XXXXXXXXXX:task/retail-store-ecs-cluster/70137dd0c1d14cf982e5a6b7446c5f54\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;public.ecr.aws/aws-containers/retail-store-sample-ui:1.2.3\u0026#34;, \u0026#34;imageDigest\u0026#34;: \u0026#34;sha256:6316a3c331c39c35798f3b1303f80494526c0a879fe5a3db3b0b9a85c22aab36\u0026#34;, \u0026#34;runtimeId\u0026#34;: \u0026#34;70137dd0c1d14cf982e5a6b7446c5f54-524788293\u0026#34;, \u0026#34;lastStatus\u0026#34;: \u0026#34;RUNNING\u0026#34;, \u0026#34;networkBindings\u0026#34;: [], \u0026#34;networkInterfaces\u0026#34;: [ { \u0026#34;attachmentId\u0026#34;: \u0026#34;464044b3-626f-44da-86ec-fa20a064d408\u0026#34;, \u0026#34;privateIpv4Address\u0026#34;: \u0026#34;10.0.4.128\u0026#34; } ], \u0026#34;healthStatus\u0026#34;: \u0026#34;HEALTHY\u0026#34;, \u0026#34;cpu\u0026#34;: \u0026#34;0\u0026#34; } ], \u0026#34;cpu\u0026#34;: \u0026#34;1024\u0026#34;, \u0026#34;createdAt\u0026#34;: \u0026#34;2024-04-10T08:09:29.943000+00:00\u0026#34;, \u0026#34;desiredStatus\u0026#34;: \u0026#34;RUNNING\u0026#34;, \u0026#34;enableExecuteCommand\u0026#34;: false, \u0026#34;group\u0026#34;: \u0026#34;service:ui\u0026#34;, \u0026#34;healthStatus\u0026#34;: \u0026#34;HEALTHY\u0026#34;, \u0026#34;lastStatus\u0026#34;: \u0026#34;RUNNING\u0026#34;, \u0026#34;launchType\u0026#34;: \u0026#34;FARGATE\u0026#34;, \u0026#34;memory\u0026#34;: \u0026#34;2048\u0026#34;, \u0026#34;overrides\u0026#34;: { \u0026#34;containerOverrides\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34; } ], \u0026#34;inferenceAcceleratorOverrides\u0026#34;: [] }, \u0026#34;platformVersion\u0026#34;: \u0026#34;1.4.0\u0026#34;, \u0026#34;platformFamily\u0026#34;: \u0026#34;Linux\u0026#34;, \u0026#34;pullStartedAt\u0026#34;: \u0026#34;2024-04-10T08:09:44.535000+00:00\u0026#34;, \u0026#34;pullStoppedAt\u0026#34;: \u0026#34;2024-04-10T08:09:52.398000+00:00\u0026#34;, \u0026#34;startedAt\u0026#34;: \u0026#34;2024-04-10T08:10:44.148000+00:00\u0026#34;, \u0026#34;startedBy\u0026#34;: \u0026#34;ecs-svc/8962710467093341990\u0026#34;, \u0026#34;tags\u0026#34;: [], \u0026#34;taskArn\u0026#34;: \u0026#34;arn:aws:ecs:us-west-2:XXXXXXXXXX:task/retail-store-ecs-cluster/70137dd0c1d14cf982e5a6b7446c5f54\u0026#34;, \u0026#34;taskDefinitionArn\u0026#34;: \u0026#34;arn:aws:ecs:us-west-2:XXXXXXXXXX:task-definition/retail-store-ecs-ui:8\u0026#34;, \u0026#34;version\u0026#34;: 4, \u0026#34;ephemeralStorage\u0026#34;: { \u0026#34;sizeInGiB\u0026#34;: 20 } } ], \u0026#34;failures\u0026#34;: [] } "
},
{
	"uri": "http://localhost:1313/3-prepare/3.1-user_accesskey/",
	"title": "Create User &amp; Access Key",
	"tags": [],
	"description": "",
	"content": "Install AWS CLI Linux: sudo apt update sudo apt install -y unzip curl curl \u0026#34;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\u0026#34; -o awscliv2.zip unzip awscliv2.zip sudo ./aws/install MacOS: curl \u0026#34;https://awscli.amazonaws.com/AWSCLIV2.pkg\u0026#34; -o AWSCLIV2.pkg sudo installer -pkg AWSCLIV2.pkg -target / Windows: msiexec.exe /i https://awscli.amazonaws.com/AWSCLIV2.msi Create User and Create Access Key Access AWS Console and create a new User with AdministratorAccess permissions.\nIn the AWS Console search bar, enter \u0026ldquo;IAM\u0026rdquo; and select \u0026ldquo;IAM\u0026rdquo;.\nSelect Users in the left menu.\nNext select Add user to create a new User.\nEnter name for User: ecs-workshop\nSelect Custom Password to create password for User.\nSelect Next.\nConfigure permissions for User:\nAttach policies directly: Select AdministratorAccess to configure permissions for User. Select Next.\nSelect Create user.\nThe User has been created successfully.\nReturn to IAM Console and select Users in the left menu.\nSelect the User just created.\nSelect Security credentials tab.\nSelect Create access key.\nSelect Command Line Interface (CLI). Confirm and proceed to next step\nDescription: Amazon ECS Immersion Day and proceed to create access key.\nThe access key has been created successfully and you can click Download .csv to download the credentials.csv file.\nConfigure AWS CLI Access CLI to configure AWS CLI.\nCheck AWS CLI version.\naws --version Configure AWS CLI.\naws configure AWS CLI has been configured successfully.\nCheck AWS CLI operation.\naws ec2 describe-instances AWS CLI has been configured successfully and is working properly.\n"
},
{
	"uri": "http://localhost:1313/5-managed-instances/5.1-enable/",
	"title": "Enable ECS Managed Instances",
	"tags": [],
	"description": "",
	"content": "In this section, you will perform setup to deploy workloads on Amazon ECS Managed Instances.\nSpecifically, we will set up default Amazon ECS capacity providers for ECS Managed Instances.\nAmazon ECS capacity providers are responsible for managing infrastructure scaling for tasks in ECS cluster.\nAmazon ECS currently provides three types of capacity providers for cluster:\nFargate capacity providers: These are pre-defined capacity providers for AWS Fargate. This is also the capacity provider we have been using from the beginning of the workshop.\nManaged Instances capacity providers: Allows using Amazon ECS Managed Instances to run workloads.\nðŸ‘‰ This is the capacity provider that will be configured in this section. Auto Scaling group capacity providers: Allows using Amazon EC2 instances to run workloads through Auto Scaling Group.\nInstance Profile is an IAM object attached directly to EC2 instance, serving as a bridge between EC2 and IAM Role.\nThrough Instance Profile, EC2 (and processes/daemons running on EC2 such as ECS Agent) can assume the corresponding IAM Role and use granted AWS permissions without needing to configure access key/secret key.\nCreate ECS Managed Instances Capacity Provider Before creating capacity provider, we need two IAM roles (refer to AWS Documentation for more details):\nInfrastructure Role: Allows Amazon ECS to manage ECS Managed Instances on your behalf.\nInstance profile: Provides permissions for Amazon ECS container agent running on managed instances.\nWe will create these two IAM roles using AWS CLI. For Infrastructure Role we will proceed to create role with name ecsManagedInstanceInfrastructureRole. First we need to create trust policy for this role with the json file content below:\nECS Agent is a daemon (background process) on EC2 instance. This agent uses Instance Profile attached to EC2 to assume the corresponding IAM Role, thereby being able to execute granted AWS permissions (e.g., call ECS API, pull image from ECR, send logs to CloudWatch).\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;ecs.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } Proceed to run the following command to create Role:\naws iam create-role \\ --role-name ecsManagedInstanceInfrastructureRole \\ --assume-role-policy-document file://ecs-managed-instance-infrastructure-role-trust.json Next we need to Attach AWS-managed policy to the role just created:\nPolicy 1 - Manage Managed Instances: aws iam attach-role-policy \\ --role-name ecsManagedInstanceInfrastructureRole \\ --policy-arn arn:aws:iam::aws:policy/AmazonECSInfrastructureRolePolicyForManagedInstances Policy 2 - Manage Volume (EBS): aws iam attach-role-policy \\ --role-name ecsManagedInstanceInfrastructureRole \\ --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSInfrastructureRolePolicyForVolumes Check if Role has been attached with policy using command:\naws iam list-attached-role-policies \\ --role-name ecsManagedInstanceInfrastructureRole Infrastructure Role has been created successfully.\nNext we will create Instance Role by creating similarly as above with json file ecs-managed-instance-role-trust.json with the json file content below:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;ec2.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } Run the following command to create Role:\naws iam create-role \\ --role-name ecsInstanceRoleManagedInstance \\ --assume-role-policy-document file://ecs-managed-instance-role-trust.json Proceed to assign ECS Agent Policy:\naws iam attach-role-policy \\ --role-name ecsInstanceRoleManagedInstance \\ --policy-arn arn:aws:iam::aws:policy/AmazonECSInstanceRolePolicyForManagedInstances Check Role again:\naws iam list-attached-role-policies \\ --role-name ecsInstanceRoleManagedInstance Create Instance Profile Proceed to create Instance Profile with the Instance Role just created:\naws iam create-instance-profile --instance-profile-name ecsInstanceRoleManagedInstanceProfile Proceed to assign Role to Instance Profile:\naws iam add-role-to-instance-profile \\ --instance-profile-name ecsInstanceRoleManagedInstanceProfile \\ --role-name ecsInstanceRoleManagedInstance Check Instance Profile again:\naws iam list-instance-profiles Instance Profile has been created successfully.\nFinally, create ECS Managed Instances capacity provider. See AWS Documentation for more information.\nThe capacity provider below will provide instances running in 2 private subnets, using UI_SG_ID security group, and have disk size 100GB. See AWS Documentation for more examples on how to configure capacity provider for Amazon ECS Managed Instances.\nWe will create capacity provider with the json file content below named retail-store-managed-instances-cp.json:\n{ \u0026#34;name\u0026#34;: \u0026#34;retail-store-managed-instances-cp\u0026#34;, \u0026#34;cluster\u0026#34;: \u0026#34;retail-store-ecs-cluster\u0026#34;, \u0026#34;managedInstancesProvider\u0026#34;: { \u0026#34;infrastructureRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/ecsManagedInstanceInfrastructureRole\u0026#34;, \u0026#34;instanceLaunchTemplate\u0026#34;: { \u0026#34;ec2InstanceProfileArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:instance-profile/ecsInstanceRoleManagedInstanceProfile\u0026#34;, \u0026#34;networkConfiguration\u0026#34;: { \u0026#34;subnets\u0026#34;: [ \u0026#34;$PRIVATE_SUBNET1\u0026#34;, \u0026#34;$PRIVATE_SUBNET2\u0026#34; ], \u0026#34;securityGroups\u0026#34;: [ \u0026#34;${UI_SG_ID}\u0026#34; ] }, \u0026#34;storageConfiguration\u0026#34;: { \u0026#34;storageSizeGiB\u0026#34;: 100 } } } } Use the following CLI to create capacity provider:\naws ecs create-capacity-provider --cli-input-json file://retail-store-managed-instances-cp.json Check capacity provider on AWS Console:\nECS Capacity Provider Details is displayed as follows:\nYour new ECS Managed Instances capacity provider with the following key characteristics:\nType: Managed Instances.\nInfrastructure Role: Configured for automatic instance management.\nInstance Profile: Allows instances to join ECS cluster.\nNetwork Configuration: Uses your existing private subnets.\nStorage: 100 GiB EBS storage for each instance.\nMonitoring: Basic CloudWatch monitoring enabled.\nAfter creating ECS Managed Instances capacity provider, proceed to the next step to deploy applications using this new compute option.\n"
},
{
	"uri": "http://localhost:1313/7-networking/7.2-service-connect/7.2.1-enable_service_connect/",
	"title": "Enable Service Connect",
	"tags": [],
	"description": "",
	"content": "In this section, we will enable ECS Service Connect in the cluster by deploying three additional microservices that UI service will communicate with:\nCreate Security Groups for Services Create Security Groups for services as follows:\nVPC ID is obtained from the VPC we created in the previous section.\nOrders Service: orders-sg\naws ec2 create-security-group \\ --group-name orders-sg \\ --description \u0026#34;Orders ECS Service SG\u0026#34; \\ --vpc-id ${VPC_ID} Checkout Service: checkout-sg aws ec2 create-security-group \\ --group-name checkout-sg \\ --description \u0026#34;Checkout ECS Service SG\u0026#34; \\ --vpc-id ${VPC_ID} Catalog Service: catalog-sg aws ec2 create-security-group \\ --group-name catalog-sg \\ --description \u0026#34;Catalog ECS Service SG\u0026#34; \\ --vpc-id ${VPC_ID} Get the IDs above and configure Inbound rules for Security Groups as follows:\nOrders Service receives traffic from UI Service and Checkout Service. aws ec2 authorize-security-group-ingress \\ --group-id ${ORDERS_SG_ID} \\ --protocol tcp \\ --port 8080 \\ --source-group ${UI_SG_ID} aws ec2 authorize-security-group-ingress \\ --group-id ${ORDERS_SG_ID} \\ --protocol tcp \\ --port 8080 \\ --source-group ${CHECKOUT_SG_ID} Checkout Service receives traffic from UI Service. aws ec2 authorize-security-group-ingress \\ --group-id ${CHECKOUT_SG_ID} \\ --protocol tcp \\ --port 8080 \\ --source-group ${UI_SG_ID} Catalog Service receives traffic from UI Service. aws ec2 authorize-security-group-ingress \\ --group-id ${CATALOG_SG_ID} \\ --protocol tcp \\ --port 8080 \\ --source-group ${UI_SG_ID} Deploy Orders Service Create ECS task definition for Orders service. We will do similarly to UI Service by using json file retail-store-ecs-order-taskdef.json with the following content:\n{ \u0026#34;family\u0026#34;: \u0026#34;retail-store-ecs-orders\u0026#34;, \u0026#34;executionRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/ordersEcsTaskExecutionRole\u0026#34;, \u0026#34;taskRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/retailStoreEcsTaskRole\u0026#34;, \u0026#34;networkMode\u0026#34;: \u0026#34;awsvpc\u0026#34;, \u0026#34;requiresCompatibilities\u0026#34;: [ \u0026#34;FARGATE\u0026#34; ], \u0026#34;cpu\u0026#34;: \u0026#34;1024\u0026#34;, \u0026#34;memory\u0026#34;: \u0026#34;2048\u0026#34;, \u0026#34;runtimePlatform\u0026#34;: { \u0026#34;cpuArchitecture\u0026#34;: \u0026#34;X86_64\u0026#34;, \u0026#34;operatingSystemFamily\u0026#34;: \u0026#34;LINUX\u0026#34; }, \u0026#34;containerDefinitions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;public.ecr.aws/aws-containers/retail-store-sample-orders:1.2.3\u0026#34;, \u0026#34;cpu\u0026#34;: 0, \u0026#34;portMappings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;containerPort\u0026#34;: 8080, \u0026#34;hostPort\u0026#34;: 8080, \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;appProtocol\u0026#34;: \u0026#34;http\u0026#34; } ], \u0026#34;essential\u0026#34;: true, \u0026#34;linuxParameters\u0026#34;: { \u0026#34;initProcessEnabled\u0026#34;: true }, \u0026#34;healthCheck\u0026#34;: { \u0026#34;command\u0026#34;: [ \u0026#34;CMD-SHELL\u0026#34;, \u0026#34;curl -f http://localhost:8080/actuator/health || exit 1\u0026#34; ], \u0026#34;interval\u0026#34;: 10, \u0026#34;timeout\u0026#34;: 5, \u0026#34;retries\u0026#34;: 3, \u0026#34;startPeriod\u0026#34;: 60 }, \u0026#34;environment\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_ORDERS_PERSISTENCE_PROVIDER\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;postgres\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_ORDERS_MESSAGING_PROVIDER\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;in-memory\u0026#34; } ], \u0026#34;secrets\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_ORDERS_PERSISTENCE_ENDPOINT\u0026#34;, \u0026#34;valueFrom\u0026#34;: \u0026#34;arn:aws:ssm:${AWS_REGION}:${ACCOUNT_ID}:parameter/retail-store-ecs/orders/db-endpoint-postgres\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_ORDERS_PERSISTENCE_NAME\u0026#34;, \u0026#34;valueFrom\u0026#34;: \u0026#34;arn:aws:secretsmanager:${AWS_REGION}:${ACCOUNT_ID}:secret:retail-store-ecs-orders-db:dbname::\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_ORDERS_PERSISTENCE_USERNAME\u0026#34;, \u0026#34;valueFrom\u0026#34;: \u0026#34;arn:aws:secretsmanager:${AWS_REGION}:${ACCOUNT_ID}:secret:retail-store-ecs-orders-db:username::\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_ORDERS_PERSISTENCE_PASSWORD\u0026#34;, \u0026#34;valueFrom\u0026#34;: \u0026#34;arn:aws:secretsmanager:${AWS_REGION}:${ACCOUNT_ID}:secret:retail-store-ecs-orders-db:password::\u0026#34; } ], \u0026#34;logConfiguration\u0026#34;: { \u0026#34;logDriver\u0026#34;: \u0026#34;awslogs\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;awslogs-group\u0026#34;: \u0026#34;retail-store-ecs-tasks\u0026#34;, \u0026#34;awslogs-region\u0026#34;: \u0026#34;$AWS_REGION\u0026#34;, \u0026#34;awslogs-stream-prefix\u0026#34;: \u0026#34;orders-service\u0026#34; } } } ] } Register task definition:\naws ecs register-task-definition \\ --cli-input-json file://retail-store-ecs-order-taskdef.json Use the following command to create Orders service:\naws ecs create-service \\ --cluster retail-store-ecs-cluster \\ --service-name orders \\ --task-definition retail-store-ecs-orders \\ --desired-count 1 \\ --launch-type FARGATE \\ --enable-execute-command \\ --network-configuration \u0026#34;awsvpcConfiguration={subnets=[subnet-0b742ee8bbf495219, subnet-0317d1d968b9963d0], securityGroups=[sg-069f1465934b99e2a],assignPublicIp=DISABLED}\u0026#34; \\ --service-connect-configuration \u0026#39;{ \u0026#34;enabled\u0026#34;: true, \u0026#34;namespace\u0026#34;: \u0026#34;retailstore.local\u0026#34;, \u0026#34;services\u0026#34;: [ { \u0026#34;portName\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;discoveryName\u0026#34;: \u0026#34;orders\u0026#34;, \u0026#34;clientAliases\u0026#34;: [ { \u0026#34;port\u0026#34;: 80, \u0026#34;dnsName\u0026#34;: \u0026#34;orders\u0026#34; } ] } ] }\u0026#39; Note: when creating service, we specify --service-connect-configuration, this will:\nEnable Service Connect.\nSpecify shared namespace for all services.\nConfigure Service Connect services provided by this ECS service, including alias and port.\nRefer to AWS Documentation for more information.\nDeploy Checkout Service Create ECS task definition for Checkout service. Similarly as above we will create task definition with json file retail-store-ecs-checkout-taskdef.json with the following content:\n{ \u0026#34;family\u0026#34;: \u0026#34;retail-store-ecs-checkout\u0026#34;, \u0026#34;executionRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/checkoutEcsTaskExecutionRole\u0026#34;, \u0026#34;taskRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/retailStoreEcsTaskRole\u0026#34;, \u0026#34;networkMode\u0026#34;: \u0026#34;awsvpc\u0026#34;, \u0026#34;requiresCompatibilities\u0026#34;: [ \u0026#34;FARGATE\u0026#34; ], \u0026#34;cpu\u0026#34;: \u0026#34;1024\u0026#34;, \u0026#34;memory\u0026#34;: \u0026#34;2048\u0026#34;, \u0026#34;runtimePlatform\u0026#34;: { \u0026#34;cpuArchitecture\u0026#34;: \u0026#34;X86_64\u0026#34;, \u0026#34;operatingSystemFamily\u0026#34;: \u0026#34;LINUX\u0026#34; }, \u0026#34;containerDefinitions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;public.ecr.aws/aws-containers/retail-store-sample-checkout:1.2.3\u0026#34;, \u0026#34;portMappings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;containerPort\u0026#34;: 8080, \u0026#34;hostPort\u0026#34;: 8080, \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;appProtocol\u0026#34;: \u0026#34;http\u0026#34; } ], \u0026#34;essential\u0026#34;: true, \u0026#34;linuxParameters\u0026#34;: { \u0026#34;initProcessEnabled\u0026#34;: true }, \u0026#34;environment\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_CHECKOUT_PERSISTENCE_PROVIDER\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;redis\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_CHECKOUT_ENDPOINTS_ORDERS\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;http://orders\u0026#34; } ], \u0026#34;secrets\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_CHECKOUT_PERSISTENCE_REDIS_URL\u0026#34;, \u0026#34;valueFrom\u0026#34;: \u0026#34;arn:aws:ssm:${AWS_REGION}:${ACCOUNT_ID}:parameter/retail-store-ecs/checkout/redis-endpoint\u0026#34; } ], \u0026#34;healthCheck\u0026#34;: { \u0026#34;command\u0026#34;: [ \u0026#34;CMD-SHELL\u0026#34;, \u0026#34;curl -f http://localhost:8080/health || exit 1\u0026#34; ], \u0026#34;interval\u0026#34;: 10, \u0026#34;timeout\u0026#34;: 5, \u0026#34;retries\u0026#34;: 3, \u0026#34;startPeriod\u0026#34;: 60 }, \u0026#34;logConfiguration\u0026#34;: { \u0026#34;logDriver\u0026#34;: \u0026#34;awslogs\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;awslogs-group\u0026#34;: \u0026#34;retail-store-ecs-tasks\u0026#34;, \u0026#34;awslogs-region\u0026#34;: \u0026#34;$AWS_REGION\u0026#34;, \u0026#34;awslogs-stream-prefix\u0026#34;: \u0026#34;checkout-service\u0026#34; } } } ] } Register task definition:\naws ecs register-task-definition \\ --cli-input-json file://retail-store-ecs-checkout-taskdef.json Use the following command to create Checkout Service:\naws ecs create-service \\ --cluster retail-store-ecs-cluster \\ --service-name checkout \\ --task-definition retail-store-ecs-checkout \\ --desired-count 1 \\ --launch-type FARGATE \\ --enable-execute-command \\ --network-configuration \u0026#34;awsvpcConfiguration={subnets=[subnet-0b742ee8bbf495219, subnet-0317d1d968b9963d0], securityGroups=[sg-037956d78913fda63],assignPublicIp=DISABLED}\u0026#34; \\ --service-connect-configuration \u0026#39;{ \u0026#34;enabled\u0026#34;: true, \u0026#34;namespace\u0026#34;: \u0026#34;retailstore.local\u0026#34;, \u0026#34;services\u0026#34;: [ { \u0026#34;portName\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;discoveryName\u0026#34;: \u0026#34;checkout\u0026#34;, \u0026#34;clientAliases\u0026#34;: [ { \u0026#34;port\u0026#34;: 80, \u0026#34;dnsName\u0026#34;: \u0026#34;checkout\u0026#34; } ] } ] }\u0026#39; Deploy Catalog Service Create Task Definition for Catalog Service. Create task definition with json file retail-store-ecs-catalog-taskdef.json with the following content:\n{ \u0026#34;family\u0026#34;: \u0026#34;retail-store-ecs-catalog\u0026#34;, \u0026#34;executionRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/catalogEcsTaskExecutionRole\u0026#34;, \u0026#34;taskRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/retailStoreEcsTaskRole\u0026#34;, \u0026#34;networkMode\u0026#34;: \u0026#34;awsvpc\u0026#34;, \u0026#34;requiresCompatibilities\u0026#34;: [ \u0026#34;FARGATE\u0026#34; ], \u0026#34;cpu\u0026#34;: \u0026#34;1024\u0026#34;, \u0026#34;memory\u0026#34;: \u0026#34;2048\u0026#34;, \u0026#34;runtimePlatform\u0026#34;: { \u0026#34;cpuArchitecture\u0026#34;: \u0026#34;X86_64\u0026#34;, \u0026#34;operatingSystemFamily\u0026#34;: \u0026#34;LINUX\u0026#34; }, \u0026#34;containerDefinitions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;public.ecr.aws/aws-containers/retail-store-sample-catalog:1.2.3\u0026#34;, \u0026#34;portMappings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;containerPort\u0026#34;: 8080, \u0026#34;hostPort\u0026#34;: 8080, \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;appProtocol\u0026#34;: \u0026#34;http\u0026#34; } ], \u0026#34;essential\u0026#34;: true, \u0026#34;linuxParameters\u0026#34;: { \u0026#34;initProcessEnabled\u0026#34;: true }, \u0026#34;environment\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_CATALOG_PERSISTENCE_DB_NAME\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;catalog\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_CATALOG_PERSISTENCE_PROVIDER\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;mysql\u0026#34; } ], \u0026#34;secrets\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_CATALOG_PERSISTENCE_ENDPOINT\u0026#34;, \u0026#34;valueFrom\u0026#34;: \u0026#34;arn:aws:ssm:${AWS_REGION}:${ACCOUNT_ID}:parameter/retail-store-ecs/catalog/db-endpoint-mysql\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_CATALOG_PERSISTENCE_PASSWORD\u0026#34;, \u0026#34;valueFrom\u0026#34;: \u0026#34;arn:aws:secretsmanager:${AWS_REGION}:${ACCOUNT_ID}:secret:retail-store-ecs-catalog-db:password::\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_CATALOG_PERSISTENCE_USER\u0026#34;, \u0026#34;valueFrom\u0026#34;: \u0026#34;arn:aws:secretsmanager:${AWS_REGION}:${ACCOUNT_ID}:secret:retail-store-ecs-catalog-db:username::\u0026#34; } ], \u0026#34;logConfiguration\u0026#34;: { \u0026#34;logDriver\u0026#34;: \u0026#34;awslogs\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;awslogs-group\u0026#34;: \u0026#34;retail-store-ecs-tasks\u0026#34;, \u0026#34;awslogs-region\u0026#34;: \u0026#34;${AWS_REGION}\u0026#34;, \u0026#34;awslogs-stream-prefix\u0026#34;: \u0026#34;catalog-service\u0026#34; } }, \u0026#34;healthCheck\u0026#34;: { \u0026#34;command\u0026#34;: [ \u0026#34;CMD-SHELL\u0026#34;, \u0026#34;curl -f http://localhost:8080/health || exit 1\u0026#34; ], \u0026#34;interval\u0026#34;: 10, \u0026#34;timeout\u0026#34;: 5, \u0026#34;retries\u0026#34;: 3, \u0026#34;startPeriod\u0026#34;: 60 } } ] } Register task definition:\naws ecs register-task-definition \\ --cli-input-json file://retail-store-ecs-catalog-taskdef.json Use the following command to create Catalog Service:\naws ecs create-service \\ --cluster retail-store-ecs-cluster \\ --service-name catalog \\ --task-definition retail-store-ecs-catalog \\ --desired-count 2 \\ --launch-type FARGATE \\ --enable-execute-command \\ --network-configuration \u0026#34;awsvpcConfiguration={subnets=[${PRIVATE_SUBNET1}, ${PRIVATE_SUBNET2}], securityGroups=[$CATALOG_SG_ID],assignPublicIp=DISABLED}\u0026#34; \\ --service-connect-configuration \u0026#39;{ \u0026#34;enabled\u0026#34;: true, \u0026#34;namespace\u0026#34;: \u0026#34;retailstore.local\u0026#34;, \u0026#34;services\u0026#34;: [ { \u0026#34;portName\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;discoveryName\u0026#34;: \u0026#34;catalog\u0026#34;, \u0026#34;clientAliases\u0026#34;: [ { \u0026#34;port\u0026#34;: 80, \u0026#34;dnsName\u0026#34;: \u0026#34;catalog\u0026#34; } ] } ] }\u0026#39; Wait for Services to be created, then update UI Service configuration so it can interact with the microservices just deployed. The following environment variables need to be added to UI Task Definition:\n\u0026#34;environment\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_UI_ENDPOINTS_ORDERS\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;http://orders\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_UI_ENDPOINTS_CHECKOUT\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;http://checkout\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_UI_ENDPOINTS_CATALOG\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;http://catalog\u0026#34; } ] Run the following script to print UI Task Definition:\ncat retail-store-ecs-ui-connect-taskdef.json | jq Register new Task Definition for UI:\naws ecs register-task-definition --cli-input-json file://retail-store-ecs-ui-connect-taskdef.json Update UI Service with new Task Definition and Service Connect configuration. Also enable Service Connect access logs to collect detailed telemetry for each request.\naws ecs update-service \\ --cluster retail-store-ecs-cluster \\ --service ui \\ --task-definition retail-store-ecs-ui \\ --force-new-deployment \\ --desired-count 2 \\ --service-connect-configuration \u0026#39;{ \u0026#34;enabled\u0026#34;: true, \u0026#34;namespace\u0026#34;: \u0026#34;retailstore.local\u0026#34;, \u0026#34;logConfiguration\u0026#34;: { \u0026#34;logDriver\u0026#34;: \u0026#34;awslogs\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;awslogs-group\u0026#34;: \u0026#34;\u0026#39;$SERVICE_CONNECT_LOG_GROUP_NAME\u0026#39;\u0026#34;, \u0026#34;awslogs-region\u0026#34;: \u0026#34;\u0026#39;$AWS_REGION\u0026#39;\u0026#34;, \u0026#34;awslogs-stream-prefix\u0026#34;: \u0026#34;ui-service-connect-logs\u0026#34; } }, \u0026#34;accessLogConfiguration\u0026#34;: { \u0026#34;format\u0026#34;: \u0026#34;JSON\u0026#34;, \u0026#34;includeQueryParameters\u0026#34;: \u0026#34;ENABLED\u0026#34; }, \u0026#34;services\u0026#34;: [ { \u0026#34;portName\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;discoveryName\u0026#34;: \u0026#34;ui\u0026#34;, \u0026#34;clientAliases\u0026#34;: [ { \u0026#34;port\u0026#34;: 80, \u0026#34;dnsName\u0026#34;: \u0026#34;ui\u0026#34; } ] } ] }\u0026#39; "
},
{
	"uri": "http://localhost:1313/4-express-mode/4.1-setup_deploy/",
	"title": "Express Mode Setup &amp; Deployment",
	"tags": [],
	"description": "",
	"content": "Before we can deploy applications using Express Mode, we need an Infrastructure Role named ecsExpressInfrastructureRole.\nThis IAM role allows Amazon ECS Express Mode to manage infrastructure components on your behalf, including:\nLoad balancers\nAuto-scaling\nNetworking configuration\nCreate Infrastructure Role First we need to create a trust policy for this role with the json file content below:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;ecs.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } Proceed to run the following command to create Role:\naws iam create-role \\ --role-name ecsExpressInfrastructureRole \\ --assume-role-policy-document file://ecs-express-trust.json Next proceed to Attach AWS-managed policy to the role just created:\naws iam attach-role-policy \\ --role-name ecsExpressInfrastructureRole \\ --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSInfrastructureRoleforExpressGatewayServices Check Infrastructure Role Managed Policy\naws iam list-attached-role-policies \\ --role-name ecsExpressInfrastructureRole We have successfully created Infrastructure Role and Attached AWS-managed policy to the role just created.\nExpress Mode Deployment We will deploy UI service similar to the Fundamentals section, but using Amazon ECS Express Mode.\nExpress Mode Service only needs three components to start:\nContainer image Task execution role Infrastructure role To run the sample application, we will use some custom parameters described in the table below:\nParameter Required Description execution-role-arn Yes IAM role used for task execution infrastructure-role-arn Yes IAM role used to manage infrastructure primary-container Yes Identifies primary container and port cluster, service-name No ECS cluster name and Express service name cpu, memory No Resources allocated for service health-check-path No Endpoint used for health check network-configuration No Identifies VPC subnets and security groups for task scaling-target No Identifies how service automatically scales number of tasks based on demand monitor-resources No Enable resource monitoring during create, update and delete Run the command below to deploy Service ui-express-mode on the existing ECS cluster retail-store-ecs-cluster.\naws ecs create-express-gateway-service \\ --execution-role-arn arn:aws:iam::${ACCOUNT_ID}:role/retailStoreEcsTaskExecutionRole \\ --infrastructure-role-arn arn:aws:iam::${ACCOUNT_ID}:role/ecsExpressInfrastructureRole \\ --service-name ui-express-mode \\ --cpu \u0026#34;1024\u0026#34; \\ --memory \u0026#34;2048\u0026#34; \\ --health-check-path \u0026#34;/actuator/health\u0026#34; \\ --cluster retail-store-ecs-cluster \\ --network-configuration \u0026#39;{ \u0026#34;subnets\u0026#34;: [\u0026#34;\u0026#39;$PUBLIC_SUBNET1\u0026#39;\u0026#34;,\u0026#34;\u0026#39;$PUBLIC_SUBNET2\u0026#39;\u0026#34;] }\u0026#39; \\ --scaling-target \u0026#39;{ \u0026#34;minTaskCount\u0026#34;: 2, \u0026#34;maxTaskCount\u0026#34;: 5, \u0026#34;autoScalingMetric\u0026#34;: \u0026#34;REQUEST_COUNT_PER_TARGET\u0026#34;, \u0026#34;autoScalingTargetValue\u0026#34;: 50 }\u0026#39; \\ --primary-container \u0026#39;{ \u0026#34;image\u0026#34;: \u0026#34;public.ecr.aws/aws-containers/retail-store-sample-ui:1.2.3\u0026#34;, \u0026#34;containerPort\u0026#34;: 8080 }\u0026#39; --monitor-resources After running the above command, ECS Express Mode will automatically:\nCreate task definition\nConfigure load balancer\nSet up service\nSet up auto-scaling\nConfigure necessary networking components\nThe --monitor-resources option will display an overview of all resources being created as shown in the image below:\nTo close monitoring, you can press q.\nWhile ECS Express Mode is creating resources, access Amazon ECS Console to view:\nActive services\nRunning tasks\nTasks and resources after being created successfully.\nProceed to get Application Load Balancer DNS and access the application.\nECS_ALB_DNS=$(aws ecs describe-express-gateway-service \\ --service-arn arn:aws:ecs:${AWS_REGION}:${ACCOUNT_ID}:service/retail-store-ecs-cluster/ui-express-mode \\ --query service.activeConfigurations[0].ingressPaths[0].endpoint \\ --output text) echo \u0026#34;https://${ECS_ALB_DNS}\u0026#34; Proceed to access the application using DNS:\nExpress Mode Review Service Overview displays service overview, you can:\nTrack service status\nView running tasks\nMonitor deployment progress\nNote the Application URL displayed on this page â€” you can use that URL to access the deployed application.\nTo monitor the application, you can view metrics of service ui-express-mode in the tabs:\nObservability\nLogs\nIn the Logs section, you can view application logs, filter specific messages, and track application behavior in real-time.\nResources tab provides an overview of all AWS resources automatically provisioned by Express Mode.\nThis list includes all infrastructure components created and managed for you, such as:\nSecurity Groups\nLoad Balancers\nTarget Groups\nCheck Express Mode configuration for the latest revision of service ui-express-mode with the following command:\nSERVICE_REVISION_ARN=$(aws ecs list-service-deployments \\ --service arn:aws:ecs:${AWS_REGION}:${ACCOUNT_ID}:service/retail-store-ecs-cluster/ui-express-mode \\ --max-results 1 \\ --query serviceDeployments[0].targetServiceRevisionArn \\ --output text) aws ecs describe-service-revisions \\ --service-revision-arn $SERVICE_REVISION_ARN During service creation, Express Mode automatically created Task Definition for the application. You can list Task Definition revisions with the following command:\naws ecs list-task-definitions --family-prefix retail-store-ecs-cluster-ui-express-mode --sort DESC --max-items 2 Check Load Balancer by opening Amazon Load Balancer Console and selecting the load balancer named ecs-express-gateway-alb-XXXXXXXX to view configuration details.\nYou can see:\nHTTPS listener Valid certificate Have been automatically configured by ECS Express Mode.\n"
},
{
	"uri": "http://localhost:1313/1-introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Amazon ECS Amazon Elastic Container Service (ECS) is a fully managed container orchestration service by AWS that simplifies deploying, managing, and scaling containerized applications. This service integrates closely with other AWS services, providing a secure, easy-to-use solution for running container workloads in the cloud environment and on-premises infrastructure through Amazon ECS Anywhere.\nAWS Fargate AWS Fargate is a serverless compute engine, operating on a pay-as-you-go model, allowing you to focus on building applications without managing servers. AWS Fargate is compatible with both Amazon Elastic Container Service (Amazon ECS) and Amazon Elastic Kubernetes Service (Amazon EKS).\nBenefits of AWS Fargate Focus on applications, not infrastructure: Deploy and manage applications without bearing operational tasks such as scaling, patching, security, and server management.\nComprehensive visibility through detailed monitoring: Monitor applications using built-in integrations with AWS services such as Amazon CloudWatch Container Insights, or collect metrics and logs through third-party tools.\nEnhanced security through workload isolation: Enhance security from design with workload isolation mechanism. Each workload running on AWS Fargate uses a separate, single-use compute instance, dedicated to one tenant, and isolated by a virtualization layer. Each Amazon ECS task or Kubernetes pod will run on a newly allocated instance. To learn more about AWS Fargate architecture, refer to AWS Fargate Security Whitepaper.\nCost-effective optimization: Only pay for compute resources actually used, with no upfront costs. Can further reduce costs by using Savings Plans, Fargate Spot, or AWS Graviton processors.\nOverview of Deployed Microservices Application Most labs in this workshop use a Microservices application to provide container components for practice exercises. The sample application simulates a simple web store where customers can browse product catalogs, add products to cart, and complete orders through the checkout process.\nThe application includes the following components and dependencies:\nComponent Description UI Provides front-end user interface and aggregates API calls to other Services Catalog API providing product list and details Cart API managing customer shopping cart Checkout API coordinating the entire checkout process Orders API receiving and processing customer orders Containerizing the Application Before deploying a workload to Amazon ECS, that workload needs to be packaged as a container image and pushed (published) to a container registry.\nSuch basic container knowledge is not within the scope of this workshop, and the application already has container images available in Amazon Elastic Container Registry (Amazon ECR) for use in labs.\nThe table below provides paths to ECR Public repositories for each component, as well as Dockerfiles used to build each component.\nComponent ECR Public repository Dockerfile UI Repository Dockerfile Catalog Repository Dockerfile Shopping cart Repository Dockerfile Checkout Repository Dockerfile Orders Repository Dockerfile "
},
{
	"uri": "http://localhost:1313/6-auto-scaling/6.1-sas/",
	"title": "Service Auto Scaling",
	"tags": [],
	"description": "",
	"content": "Service Auto Scaling Amazon ECS integrates with Amazon CloudWatch to allow scaling ECS services effectively based on real-time metrics. These metrics are transmitted from Amazon ECS to CloudWatch every minute, enabling accurate monitoring and timely scaling decisions.\nWhen metrics exceed thresholds defined in scaling policy, CloudWatch will trigger an alarm to adjust desired number of tasks in your service. This dynamic adjustment process will increase desired capacity in scale-out events and decrease in scale-in events, ensuring optimal resource usage.\nAmazon ECS provides three advanced service scaling strategies:\nTarget Tracking Scaling:\nThis method aims to maintain a scaling metric at a specific target value by automatically adjusting the number of tasks. Target tracking scaling is preferred due to its simplicity and low maintenance requirements, making it an ideal choice for businesses wanting to achieve operational efficiency without frequent manual intervention. Step Scaling:\nThis strategy provides more detailed control over scaling actions. Users can choose metrics, set threshold values, and define step adjustments to specify the amount of resources to add or remove. It also allows customizing breach evaluation periods for metric alarms, providing a flexible approach to efficiently handle volatile workloads. Scheduled Scaling:\nThis method is most suitable when scaling actions can be predicted in advance based on known demand patterns. It is ideal for applications with predictable traffic fluctuations, allowing proactive resource management to ensure service stability and performance during peak times. Target Tracking Scaling Automatically maintain metric around a target value. ECS doesn\u0026rsquo;t care how many tasks need to be added, it only cares:\n\u0026ldquo;Is the current metric deviating from the target value?\u0026rdquo;\nIf deviating â†’ ECS automatically calculates the number of tasks to scale.\ndesiredTasks = currentTasks Ã— (currentMetric / targetMetric) Example: CPU-based scaling\nMetric: ECSServiceAverageCPUUtilization Target value: 50% Currently: 2 tasks CPU = 90% desiredTasks = 2 Ã— (90 / 50) = 3.6 â‰ˆ 4 tasks -\u0026gt; ECS scales 2 â†’ 4 tasks.\nAdvantages: Easy to configure No complex tuning needed Low maintenance Avoids over-scaling Disadvantages: Less detailed control Not suitable for workloads with very fast spikes When to use?\n80â€“90% of ECS services. Web services, APIs, microservices. Gradually increasing or relatively stable load. Step Scaling Scale by \u0026ldquo;steps\u0026rdquo; based on threshold.\nProactively define:\nWhich metric When threshold is exceeded by how much Then scale how many tasks ECS doesn\u0026rsquo;t calculate automatically, but follows the established rules exactly.\nExample: CPU-based Step Scaling\nMetric: CPUUtilization CPU Action â‰¥ 60% +1 task â‰¥ 75% +2 tasks â‰¥ 90% +4 tasks â‰¤ 30% -1 task Service has 2 tasks and CPU increases to 85% -\u0026gt; ECS increases to 2 tasks. Step scaling uses CloudWatch Alarm:\nExample:\nCPU â‰¥ 75% Maintain for 2 consecutive minutes â†’ Trigger scale action Avoid scaling due to short-term spikes (increase briefly then decrease).\nAdvantages\nVery detailed control Suitable for highly volatile workloads Can use non-proportional metrics Disadvantages\nComplex configuration Easy to make mistakes if tuning is poor Requires frequent monitoring \u0026amp; adjustment When to use?\nWorkloads with strong, non-linear spikes Batch processing Legacy systems When you need precise control over number of tasks to increase/decrease Scheduled Scaling Scale according to schedule.\nConfigurer knows in advance: When load is high, when load is low.\nECS scales according to preset time, no metric needed.\nExample: Business hours website with operating hours from 8:00 to 18:00.\nTime Tasks 08:00 â€“ 18:00 6 18:00 â€“ 08:00 2 Advantages\nVery stable Not dependent on metrics Avoids cold start Disadvantages\nCannot react to unexpected traffic Must predict correctly When to use?\nTraffic with clear patterns Business hours Fixed events (sales, livestreams, exam systems) "
},
{
	"uri": "http://localhost:1313/",
	"title": "Workshop Amazon Elastic Container Service &amp; AWS Fargate",
	"tags": [],
	"description": "",
	"content": "Workshop Amazon Elastic Container Service \u0026amp; AWS Fargate Welcome to Amazon Elastic Container Service Immersion Day!\nAmazon Elastic Container Service (ECS) is a fully managed Container Orchestration Service by AWS. It allows you to deploy, manage, and scale containerized applications quickly and efficiently.\nECS can integrate with the AWS ecosystem, providing an easy-to-use solution for running container workloads in the cloud environment, while supporting advanced security capabilities through Amazon ECS Anywhere.\nAWS Fargate is a Serverless service, pay-as-you-go, that allows you to build applications without worrying about infrastructure. By delegating server management, resource allocation, and scaling to AWS, this helps enhance operational capabilities, accelerate the process of bringing ideas to production, and optimize TCO (Total Cost of Ownership).\nWhat will you learn through this workshop? Understand the fundamental concepts of Amazon ECS and AWS Fargate: cluster, task, and service. Deploy autoscaling for workloads to meet changing load levels. Monitor workload behavior through logs, metrics, and traces. Grasp networking in AWS Fargate and advanced networking concepts. Explore security aspects, including secure credential and secret management. Learn different workload deployment strategies on Amazon ECS. Target Audience Workshop at 200+ level, suitable for those who want hands-on experience with Amazon ECS, familiarize themselves with ECS core components, as well as practical applications in deploying and managing containerized workloads. Pre-requisites This is not an introductory workshop on containers. Participants need foundational knowledge about Containers, specifically:\nUnderstanding of Containers, including the ability to build containers using Dockerfile. Basic knowledge and familiarity with AWS Management Console, AWS APIs. Main Content Introduction Preparation Express Mode Managed Instances Auto Scaling Networking Observability Security Deployments Storage Cost Optimizations Clean Up "
},
{
	"uri": "http://localhost:1313/4-express-mode/4.2-update/",
	"title": "Express Mode Update",
	"tags": [],
	"description": "",
	"content": "Update Service In this section, we will update service ui-express-mode by changing the default application interface to orange color through updating environment variable.\n\u0026#34;environment\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;RETAIL_UI_THEME\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;orange\u0026#34; }] Run the following command to update Service ui-express-mode.\naws ecs update-express-gateway-service \\ --service-arn arn:aws:ecs:${AWS_REGION}:${ACCOUNT_ID}:service/retail-store-ecs-cluster/ui-express-mode \\ --primary-container \u0026#39;{ \u0026#34;image\u0026#34;: \u0026#34;public.ecr.aws/aws-containers/retail-store-sample-ui:1.2.3\u0026#34;, \u0026#34;environment\u0026#34;: [{ \u0026#34;name\u0026#34;: \u0026#34;RETAIL_UI_THEME\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;orange\u0026#34; }] }\u0026#39; Open Amazon ECS Console:\nSelect Deployments tab.\nSelect the deployment in progress.\nView deployment process details.\nAmazon ECS Express Mode uses ECS canary deployment strategy.\nThis mechanism works as follows:\nInitially, a small percentage of traffic will be routed to the new revision for testing.\nAfter the canary phase completes successfully, all remaining traffic will be routed to the new revision in one go.\nCheck application Get Application Load Balancer DNS:\nECS_ALB_DNS=$(aws ecs describe-express-gateway-service \\ --service-arn arn:aws:ecs:${AWS_REGION}:${ACCOUNT_ID}:service/retail-store-ecs-cluster/ui-express-mode \\ --query service.activeConfigurations[0].ingressPaths[0].endpoint \\ --output text) echo \u0026#34;https://${ECS_ALB_DNS}\u0026#34; Proceed to access the application using DNS:\n"
},
{
	"uri": "http://localhost:1313/2-fundamentals/2.1-ecs_cluster/",
	"title": "Amazon ECS Cluster",
	"tags": [],
	"description": "",
	"content": "Amazon ECS Cluster ECS Cluster is a container runtime environment, a logical group for managing compute resources.\nInside ECS Cluster there will be EC2 instances or Fargate capacity to run containers.\nAll Tasks and Services will be managed by ECS Cluster.\nCluster is NOT a machine, it is just a management area.\nComparison of 2 Launch Type styles in ECS: ECS on EC2 ECS on Fargate You manage server âœ” âœ— Control instance type âœ” âœ— Pay per instance âœ” âœ— Serverless âœ— âœ” Suitable large, stable workload microservice, startup "
},
{
	"uri": "http://localhost:1313/2-fundamentals/2.2-ecs_service/",
	"title": "Amazon ECS Service",
	"tags": [],
	"description": "",
	"content": "Amazon ECS Service ECS Service is a management tool that allows you to run and maintain a certain number of tasks continuously in an ECS cluster. It is an essential part of ECS for long-term applications, unlike standalone tasks used for short-term batch jobs.\nIf one of the tasks fails or stops, the ECS Service Scheduler will launch another instance of the Task Definition to replace it.\nThis helps maintain the correct desired number of tasks for the service.\nAdditionally, only Service can be configured with Load Balancer. If you need to distribute traffic to containers, you must use Service, not standalone Task. LB helps:\nHigh availability Scale Health check When to use Service Scheduler? AWS recommends using Service Scheduler for:\nServices Stateless applications Long-running workloads Service Scheduler ensures:\nYour configured scheduling strategy is followed Tasks are rescheduled when they fail Example: If the underlying infrastructure fails, Service Scheduler will restart the task.\nECS Service Configuration Components Service Name: Name of the service to identify it in the cluster\nTask Definition: Which Task Definition will be used to launch tasks. Service will reference this Task Definition.\nDesired Count: Number of tasks you want Service to keep running continuously. If you specify desired count as 3, Service will always try to maintain 3 running tasks. If a task stops, Service will launch a new task to replace it.â€‹\nScheduling Strategy: There are two options:\nREPLICA: Service runs a desired number of tasks\nDAEMON: Service runs one task on each container instance in the cluster (no desired count)â€‹\nDeployment Type: How to deploy new versions:â€‹\nECS: Use ECS Scheduler (default rolling update)\nCODE_DEPLOY: Use AWS CodeDeploy (supports blue-green deployments)\nEXTERNAL: Allows manual deployment through TaskSets (used with CloudFormation, Jenkins, etc.)\nLoad Balancer Configuration: If you want to distribute traffic:\nLoad Balancer Type: Application Load Balancer (ALB) or Network Load Balancer (NLB)\nTarget Group: Identifies which containers will receive traffic\nPort Mapping: Maps from load balancer port to container port\nHealth Check: Health check configuration to determine if task is functioningâ€‹\nECS Service Lifecycle Service operates in the following cycle:\nInitialization: You create Service and specify desired count (e.g., 3 tasks)\nLaunch Tasks: Service scheduler launches 3 instances of Task Definition\nRegister with Load Balancer: If there is a load balancer, tasks are automatically registered with target group\nContinuous Monitoring: Service continuously checks the status of tasks\nReplace Failed Tasks: If a task encounters an issue, Service launches a new task to maintain desired count\nScale Up/Down: If auto scaling is enabled, desired count will automatically adjust based on metrics\nDeployment Configuration for Rolling Updates When you deploy a new version of the application (update Task Definition), ECS uses deployment configuration to control the process:\nMinimumHealthyPercent: Minimum percentage of tasks that must remain in RUNNING state throughout the deployment process. For example, if desired count is 4 and MinimumHealthyPercent is 50%, ECS ensures at least 2 tasks (50% of 4) are still running when deploying new versions.â€‹\nMaximumPercent: Maximum total number of tasks that can run simultaneously throughout the deployment process, expressed as a percentage of desired count. For example, if desired count is 4 and MaximumPercent is 200%, ECS allows up to 8 tasks to run at the same time - 4 old tasks + 4 new tasks. This allows faster deployment but requires more resources.â€‹â€‹\nExample deployment process:\nYou have 4 tasks running version v1.\nYou update Task Definition to version v2.\nMinimumHealthyPercent: 100%\nMaximumPercent: 200%\nECS launches 4 new tasks (v2) before stopping 4 old tasks (v1).\nAt this point you have 8 tasks running simultaneously.\nThen, ECS stops the 4 old v1 tasks.\nResult: 4 v2 tasks running.\nService Auto Scalingâ€‹ Service Auto Scaling allows ECS to automatically adjust the number of tasks based on metrics such as CPU, memory, or custom metrics. There are four types of scaling:\nTarget Tracking Scaling: Maintains a specific metric at a target level. For example, you can say \u0026ldquo;maintain CPU at 70%\u0026rdquo;. ECS will automatically add tasks when CPU exceeds 70% and remove tasks when CPU is below 70%.â€‹\nStep Scaling: Uses CloudWatch alarms with steps. For example, when CPU \u0026gt; 80%, add 2 tasks; when CPU \u0026gt; 90%, add 4 tasks.â€‹\nScheduled Scaling: Adjusts desired count based on schedule. For example, scale up at 9 AM when company opens, scale down at 6 PM when closing.â€‹\nPredictive Scaling: Uses machine learning to analyze historical patterns and predict future traffic.â€‹\nMechanism for Maintaining Desired Count It is important to understand that desired count and the actual number of running tasks may differ temporarily:\nDesired Count: Number of tasks you want Service to maintain. It is a target value that ECS tries to achieve.â€‹ Running Tasks: Actual number of tasks running at the current time. When you change desired count, ECS needs time to launch or stop tasks to match the new desired count.â€‹ Example:\nYou set desired count = 3 Currently there is 1 task running ECS will launch 2 new tasks During launch, running tasks = 1 but desired count = 3 After a few seconds, running tasks = 3 (matches desired count) Deployment vs Auto Scalingâ€‹ Service Auto Scaling Min/Max is the allowed range that Service Auto Scaling can adjust desired count within.\nIf you set Min = 2 and Max = 10:\nService Auto Scaling will never let desired count go below 2\nService Auto Scaling will never let desired count exceed 10\nDeployment Configuration Min/Max Percent only applies during the deployment process (when updating Task Definition). It controls how many tasks can run during deployment, unrelated to normal auto scaling.\n"
},
{
	"uri": "http://localhost:1313/2-fundamentals/2.3-ecs_task/",
	"title": "Amazon ECS Task",
	"tags": [],
	"description": "",
	"content": "Amazon ECS Task Task represents a running instance of a Task Definition in an ECS cluster. Task is the result when we launch a Task Definition at a specific time in a cluster. If we specify running 3 tasks from a Task Definition, AWS ECS will launch 3 separate instances of that Task Definition.\nTask Lifecycle When a task is launched (either as part of a service, or as a standalone task), it will go through many different states:\nPROVISIONING â†’ PENDING â†’ ACTIVATING â†’ RUNNING â†’ DEACTIVATING â†’ STOPPING â†’ DEPROVISIONING â†’ STOPPED\rEach state has meaning:\nPROVISIONING: ECS is allocating necessary resources (Fargate only).\nPENDING: Task is waiting for resources (CPU, memory) to be allocated from cluster.\nACTIVATING: Container is starting and health checks are occurring.\nRUNNING: Container is running normally.\nDEACTIVATING: Task is preparing to stop.\nSTOPPING: Task is being stopped.\nDEPROVISIONING: Resources are being released (Fargate only).\nSTOPPED: Task has completely stopped.\nECS tracks two different states:\nlastStatus: Current actual state of the task.\ndesiredStatus: Target state we want the task to achieve.\nFor example, if we request to stop a task, lastStatus might be RUNNING while desiredStatus will be STOPPED.\nTask Execution Role vs Task Role There are two types of IAM roles in ECS task:\nTask Execution Role: is the role used by ECS Container Agent (not container application). It grants permissions to ECS agent to perform actions such as:\nPull Docker images from Amazon ECR Access Secrets Manager or Parameter Store to get configuration Send logs to CloudWatch Logs Pull files from S3 to launch Task Role: is the role used by the application inside the container. It allows the application to call other AWS services such as:\nS3 (to read/write files) DynamoDB (to access database) SNS/SQS (to send messages) RDS (to access database) How ECS Places Tasks on Container Instances When we run a task on an EC2-based cluster, ECS must decide which instance it will run on. This process is called task placement, and it can be controlled by Placement Strategies and Placement Constraints.\nPlacement Strategies:\nspread: Distribute tasks across multiple instances based on an attribute (e.g., ecs.availability-zone, ecs.instance-type). Good for high availability\nbinpack: Pack tasks into as few instances as possible to save costs\nrandom: Place tasks randomly (rarely used)\nPlacement Constraints:\ndistinctInstance: Ensure each task runs on a different instance\nmemberOf: Only place tasks on instances with specific attributes/tags\nTasks - Standalone vs Service Standalone Task: Used for short-term jobs (batch jobs, one-off tasks). Task will run until completion or error, then stop. No automatic restart mechanism.\nService Task: Used for long-term applications. Service scheduler automatically maintains the desired number of tasks by restarting any stopped task.\n"
},
{
	"uri": "http://localhost:1313/2-fundamentals/2.4-ecs_task_definition/",
	"title": "Amazon ECS Task Definition",
	"tags": [],
	"description": "",
	"content": "Amazon ECS Task Definition Task Definition is a JSON blueprint describing how one or more Docker containers will run in AWS ECS. It is like a recipe or template containing all necessary configurations to launch containers, including Docker image, CPU, memory, port mappings, environment variables, logging, and more.\nMain Components of Task Definition Task Definition is divided into two configuration levels: Task-level parameters and Container definitions.\nTask-Level Parameters\nFamily: Name of the Task Definition family. This is the name used to identify the task definition. Example: \u0026ldquo;my-web-app\u0026rdquo;, \u0026ldquo;data-processor\u0026rdquo;. When updating task definition, a new revision is created but family name remains the same.â€‹\nTask Size (CPU \u0026amp; Memory): Total CPU and memory allocated for the entire task. This is different from CPU/memory at container level. With Fargate, these values are required and must be specific supported values (e.g., 0.25 vCPU with 0.5GB-1GB memory). With EC2, these values are optional.â€‹\nNetwork Mode: How containers will connect to network:â€‹\nawsvpc: Each task receives a separate Elastic Network Interface (ENI) with a separate IP address from VPC. This allows task to operate like an EC2 instance in VPC. This is the only mode supported by Fargate and recommended for EC2.â€‹\nbridge: Containers connect via Docker bridge network. Containers on the same host can communicate with each other. Port mapping is used to expose ports.â€‹\nhost: Containers share network namespace with host. Container ports are mapped directly with host ports. Not recommended as it reduces isolation.\nnone: Containers have no network connectivity.â€‹\nLaunch Type: Where task will run:\nEC2: Task runs on EC2 instances managed by you.\nFargate: AWS manages infrastructure, you only need to define requirements\nExecution Role (Task Execution Role ARN): IAM role for ECS Container Agent. This role allows agent to pull Docker images from ECR, push logs to CloudWatch, get secrets from Secrets Manager.â€‹\nTask Role: IAM role for application inside container. This role grants permissions for code to access AWS services such as S3, DynamoDB, SNS, etc.â€‹\nPlatform: CPU architecture type (x86_64 or ARM64). With ARM64, can use AWS Graviton processors for cost savings.â€‹\nContainer Definitions\nTask Definition can contain one or more container definitions. Each container definition describes a separate container that will run as part of the task.\nName: Name of container (e.g., web-server, database-client). Required.â€‹\nImage: Docker image URI to use. Can be from Docker Hub (e.g., nginx:latest) or from Amazon ECR (e.g., 123456789012.dkr.ecr.us-east-1.amazonaws.com/my-app:1.0.0). Required.â€‹\nCPU: Number of CPU units allocated for this container. 1 vCPU = 1024 CPU units. If task size is 1 vCPU and 2 containers, can allocate 512 units for each container. If set to 0, container will use remaining CPU units not allocated to other containers.â€‹\nMemory: Memory in MB. It can be:\nhard limit (memory): Maximum memory container can use. If exceeded, container is stopped.\nsoft limit (memoryReservation): Memory guaranteed available for container.â€‹\nExample: containerPort 8080 â†’ hostPort 0 means container runs on port 8080, but exposed via dynamic port mapping on host.â€‹\nEssential: Boolean flag. If true, if this container fails, the entire task will be stopped. At least one container must have essential=true. If false, task will continue running even when this container stops.â€‹\nEnvironment Variables: Environment variables passed to container. Example: SERVER_PORT=8080, DATABASE_HOST=db.example.com.â€‹\nLogging Configuration: How logs will be written. Options include:\nawslogs: Logs pushed to AWS CloudWatch\nsplunk: Logs pushed to Splunk\ndatadog: Logs pushed to Datadog\nawsfirelens: Use Fluent Bit or Fluentd\nExample CloudWatch configuration:\n\u0026#34;logConfiguration\u0026#34;: { \u0026#34;logDriver\u0026#34;: \u0026#34;awslogs\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;awslogs-group\u0026#34;: \u0026#34;/ecs/my-task\u0026#34;, \u0026#34;awslogs-region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;awslogs-stream-prefix\u0026#34;: \u0026#34;ecs\u0026#34; } } Mount Points: Map volumes into container. Includes:\nsourceVolume: Name of volume defined at task-level\ncontainerPath: Path inside container where volume is mounted (e.g., /data)\nreadOnly: Whether it is read-onlyâ€‹\nHealth Check: Health check configuration for container:\n\u0026#34;healthCheck\u0026#34;: { \u0026#34;command\u0026#34;: [\u0026#34;CMD-SHELL\u0026#34;, \u0026#34;curl -f http://localhost:8080/health || exit 1\u0026#34;], \u0026#34;interval\u0026#34;: 30, \u0026#34;timeout\u0026#34;: 5, \u0026#34;retries\u0026#34;: 3, \u0026#34;startPeriod\u0026#34;: 0 } Volumes (Data Storage)â€‹\nVolumes: Volumes are defined at task-level but mounted into containers through mount points. Volume types include:\nEBS Volumes: Amazon Elastic Block Store volumes for persistent storage (EC2 only)\nEFS Volumes: Amazon Elastic File System for shared persistent storage between multiple tasks/instances\nFSx Volumes: FSx for Windows File Server volumes\nBind Mounts: Mount a path from host EC2 instance into container\nDocker Volumes: Docker-managed volumes\nExample volume definition:\n\u0026#34;volumes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;my-efs\u0026#34;, \u0026#34;efsVolumeConfiguration\u0026#34;: { \u0026#34;fileSystemId\u0026#34;: \u0026#34;fs-1234567\u0026#34;, \u0026#34;transitEncryption\u0026#34;: \u0026#34;ENABLED\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;my-bind-volume\u0026#34;, \u0026#34;host\u0026#34;: { \u0026#34;sourcePath\u0026#34;: \u0026#34;/mnt/data\u0026#34; } } ] Versioning and Revisionsâ€‹\nTask Definitions are immutable. This means you cannot edit an existing task definition. Instead, you must create a new revision.â€‹\nRevision is a copy of the current task definition with changes applied. Each task definition family can have multiple revisions:\nmy-app:1 (revision 1).\nmy-app:2 (revision 2).\nmy-app:3 (revision 3).\nWhen updating a service or running a task, specify family:revision to use (e.g., \u0026ldquo;my-app:3\u0026rdquo;). This allows easy rollback to old revision if there are issues by simply updating service to use previous revision.â€‹\nAdvantages of this architecture:\nAudit trail: Can view all changes that have been made.\nEasy rollback: Roll back to old revision if needed.\nVersion control: Like version control for infrastructure.\nTask Definition JSON\n{ \u0026#34;family\u0026#34;: \u0026#34;my-web-app\u0026#34;, \u0026#34;cpu\u0026#34;: \u0026#34;256\u0026#34;, \u0026#34;memory\u0026#34;: \u0026#34;512\u0026#34;, \u0026#34;networkMode\u0026#34;: \u0026#34;awsvpc\u0026#34;, \u0026#34;requiresCompatibilities\u0026#34;: [\u0026#34;FARGATE\u0026#34;], \u0026#34;executionRoleArn\u0026#34;: \u0026#34;arn:aws:iam::123456789012:role/ecsTaskExecutionRole\u0026#34;, \u0026#34;taskRoleArn\u0026#34;: \u0026#34;arn:aws:iam::123456789012:role/ecsTaskRole\u0026#34;, \u0026#34;containerDefinitions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;web-server\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;123456789012.dkr.ecr.us-east-1.amazonaws.com/my-app:1.0.0\u0026#34;, \u0026#34;cpu\u0026#34;: 256, \u0026#34;memory\u0026#34;: 512, \u0026#34;essential\u0026#34;: true, \u0026#34;portMappings\u0026#34;: [ { \u0026#34;containerPort\u0026#34;: 8080, \u0026#34;hostPort\u0026#34;: 8080, \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34; } ], \u0026#34;logConfiguration\u0026#34;: { \u0026#34;logDriver\u0026#34;: \u0026#34;awslogs\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;awslogs-group\u0026#34;: \u0026#34;/ecs/my-web-app\u0026#34;, \u0026#34;awslogs-region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;awslogs-stream-prefix\u0026#34;: \u0026#34;ecs\u0026#34; } }, \u0026#34;environment\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;ENVIRONMENT\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;production\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;DATABASE_HOST\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;db.example.com\u0026#34; } ] } ] } "
},
{
	"uri": "http://localhost:1313/3-prepare/3.2-cluster-task_definitions/",
	"title": "Create Cluster &amp; Task Definition",
	"tags": [],
	"description": "",
	"content": "Create Cluster Proceed to create Amazon ECS Cluster named retail-store-ecs-cluster with CloudWatch Container Insights.\nContainer Insight collects, aggregates and summarizes metrics and logs from Container applications.\naws ecs create-cluster --cluster-name retail-store-ecs-cluster --capacity-providers FARGATE FARGATE_SPOT --default-capacity-provider-strategy capacityProvider=FARGATE,weight=1 --settings name=containerInsights,value=enhanced After running the command, you will get the following result and can see CloudWatch Container Insights has been configured successfully.\n{ \u0026#34;cluster\u0026#34;: { \u0026#34;clusterArn\u0026#34;: \u0026#34;arn:aws:ecs:ap-northeast-2:111111111111:cluster/retail-store-ecs-cluster\u0026#34;, \u0026#34;clusterName\u0026#34;: \u0026#34;retail-store-ecs-cluster\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;ACTIVE\u0026#34;, \u0026#34;registeredContainerInstancesCount\u0026#34;: 0, \u0026#34;runningTasksCount\u0026#34;: 0, \u0026#34;pendingTasksCount\u0026#34;: 0, \u0026#34;activeServicesCount\u0026#34;: 0, \u0026#34;statistics\u0026#34;: [], \u0026#34;tags\u0026#34;: [], \u0026#34;settings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;containerInsights\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;enhanced\u0026#34; } ], \u0026#34;capacityProviders\u0026#34;: [], \u0026#34;defaultCapacityProviderStrategy\u0026#34;: [] } } Check on AWS Console to confirm cluster has been created successfully.\nCreate Role Create two IAM Roles needed for ECS Task:\nretailStoreEcsTaskExecutionRole: allows ECS to pull image, write logs, access secrets.\nretailStoreEcsTaskRole: grants permissions for application inside container.\naws iam create-role --role-name retailStoreEcsTaskExecutionRole --assume-role-policy-document file://ecs-task-trust.json Content of ecs-task-trust.json file:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;ecs-tasks.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } Attach permissions to retailStoreEcsTaskExecutionRole:\naws iam attach-role-policy --role-name retailStoreEcsTaskExecutionRole --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy Create retailStoreEcsTaskRole:\naws iam create-role --role-name retailStoreEcsTaskRole --assume-role-policy-document file://ecs-task-trust.json Create Task Definition Create Task Definition named retail-store-ecs-ui used for UI Service with the following configuration:\n{ \u0026#34;family\u0026#34;: \u0026#34;retail-store-ecs-ui\u0026#34;, \u0026#34;networkMode\u0026#34;: \u0026#34;awsvpc\u0026#34;, \u0026#34;requiresCompatibilities\u0026#34;: [ \u0026#34;FARGATE\u0026#34; ], \u0026#34;cpu\u0026#34;: \u0026#34;1024\u0026#34;, \u0026#34;memory\u0026#34;: \u0026#34;2048\u0026#34;, \u0026#34;runtimePlatform\u0026#34;: { \u0026#34;cpuArchitecture\u0026#34;: \u0026#34;X86_64\u0026#34;, \u0026#34;operatingSystemFamily\u0026#34;: \u0026#34;LINUX\u0026#34; }, \u0026#34;containerDefinitions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;public.ecr.aws/aws-containers/retail-store-sample-ui:1.2.3\u0026#34;, \u0026#34;portMappings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;containerPort\u0026#34;: 8080, \u0026#34;hostPort\u0026#34;: 8080, \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;appProtocol\u0026#34;: \u0026#34;http\u0026#34; } ], \u0026#34;essential\u0026#34;: true, \u0026#34;linuxParameters\u0026#34;: { \u0026#34;initProcessEnabled\u0026#34;: true }, \u0026#34;healthCheck\u0026#34;: { \u0026#34;command\u0026#34;: [ \u0026#34;CMD-SHELL\u0026#34;, \u0026#34;curl -f http://localhost:8080/actuator/health || exit 1\u0026#34; ], \u0026#34;interval\u0026#34;: 10, \u0026#34;timeout\u0026#34;: 5, \u0026#34;retries\u0026#34;: 3, \u0026#34;startPeriod\u0026#34;: 60 }, \u0026#34;logConfiguration\u0026#34;: { \u0026#34;logDriver\u0026#34;: \u0026#34;awslogs\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;awslogs-group\u0026#34;: \u0026#34;retail-store-ecs-tasks\u0026#34;, \u0026#34;awslogs-region\u0026#34;: \u0026#34;$AWS_REGION\u0026#34;, \u0026#34;awslogs-stream-prefix\u0026#34;: \u0026#34;ui-service\u0026#34; } } } ], \u0026#34;executionRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/retailStoreEcsTaskExecutionRole\u0026#34;, \u0026#34;taskRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/retailStoreEcsTaskRole\u0026#34; } Note ACCOUNT_ID is your AWS account ID, AWS_REGION is your region.\nCreate a json file with the above content and name it retail-store-ecs-ui-taskdef.json.\nRun the following command to create Task Definition.\naws ecs register-task-definition --cli-input-json file://retail-store-ecs-ui-taskdef.json Check on AWS Console to confirm Task Definition has been created successfully.\nYou can retrieve the successfully created Task Definition by running the following command:\naws ecs describe-task-definition --task-definition retail-store-ecs-ui "
},
{
	"uri": "http://localhost:1313/5-managed-instances/5.2-deploy/",
	"title": "Deploy with Managed Instances",
	"tags": [],
	"description": "",
	"content": "Register Task Definition We will deploy UI service (ui-managed-instance) using ECS Managed Instances that we created in the previous step.\nProceed to register a new task definition named retail-store-ecs-ui-managed using the json file retail-store-ecs-ui-managed-taskdef.json below:\n{ \u0026#34;family\u0026#34;: \u0026#34;retail-store-ecs-ui-managed\u0026#34;, \u0026#34;networkMode\u0026#34;: \u0026#34;awsvpc\u0026#34;, \u0026#34;requiresCompatibilities\u0026#34;: [ \u0026#34;MANAGED_INSTANCES\u0026#34; ], \u0026#34;cpu\u0026#34;: \u0026#34;1024\u0026#34;, \u0026#34;memory\u0026#34;: \u0026#34;2048\u0026#34;, \u0026#34;runtimePlatform\u0026#34;: { \u0026#34;cpuArchitecture\u0026#34;: \u0026#34;X86_64\u0026#34;, \u0026#34;operatingSystemFamily\u0026#34;: \u0026#34;LINUX\u0026#34; }, \u0026#34;containerDefinitions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;public.ecr.aws/aws-containers/retail-store-sample-ui:1.2.3\u0026#34;, \u0026#34;portMappings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;containerPort\u0026#34;: 8080, \u0026#34;hostPort\u0026#34;: 8080, \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;appProtocol\u0026#34;: \u0026#34;http\u0026#34; } ], \u0026#34;versionConsistency\u0026#34;: \u0026#34;disabled\u0026#34;, \u0026#34;essential\u0026#34;: true, \u0026#34;linuxParameters\u0026#34;: { \u0026#34;initProcessEnabled\u0026#34;: true }, \u0026#34;healthCheck\u0026#34;: { \u0026#34;command\u0026#34;: [ \u0026#34;CMD-SHELL\u0026#34;, \u0026#34;curl -f http://localhost:8080/actuator/health || exit 1\u0026#34; ], \u0026#34;interval\u0026#34;: 10, \u0026#34;timeout\u0026#34;: 5, \u0026#34;retries\u0026#34;: 3, \u0026#34;startPeriod\u0026#34;: 60 }, \u0026#34;logConfiguration\u0026#34;: { \u0026#34;logDriver\u0026#34;: \u0026#34;awslogs\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;awslogs-group\u0026#34;: \u0026#34;retail-store-ecs-tasks\u0026#34;, \u0026#34;awslogs-region\u0026#34;: \u0026#34;$AWS_REGION\u0026#34;, \u0026#34;awslogs-stream-prefix\u0026#34;: \u0026#34;ui-managed-service\u0026#34; } } } ], \u0026#34;executionRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/retailStoreEcsTaskExecutionRole\u0026#34;, \u0026#34;taskRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/retailStoreEcsTaskRole\u0026#34; } Run the following command to register the new task definition:\naws ecs register-task-definition --cli-input-json file://retail-store-ecs-ui-managed-taskdef.json Create Target Group \u0026amp; Application Load Balancer Access EC2 Console:\nSelect Target Groups section and select Create Target Group.\nConfigure the following parameters:\nTarget Group Name: ui-managed-tg Target Type: IP Addresses Protocol: HTTP Port: 8080 VPC: VPC we created in the previous step. Health Check Protocol: HTTP Health Check Path: /actuator/health After configuration is complete, select Next.\nReview the parameters and select Create Target Group.\nWe have successfully created Target Group. Next we will create Application Load Balancer.\nContinue accessing EC2 Console and select Load Balancers and select Create Load Balancer.\nSelect Type as Application Load Balancer.\nConfigure the following parameters:\nLoad Balancer Name: ui-managed-alb Scheme: Internet-facing VPC: VPC we created in the previous step. Configure 2 Public Subnets for ALB. Select alb-sg just created and select Target Group ui-managed-tg. Review and select Create Load Balancer.\nWe have successfully created Application Load Balancer.\nCreate ECS Service Now, create a new UI service to use Amazon ECS Managed Instances capacity provider.\nNote variables such as:\nUI_TG_ARN: ARN of the Target Group just created.\nPRIVATE_SUBNET1: ID of the first Private Subnet we created in the previous step.\nPRIVATE_SUBNET2: ID of the second Private Subnet we created in the previous step.\nUI_SG_ID: ID of Security Group ui-sg.\naws ecs create-service \\ --cluster retail-store-ecs-cluster \\ --service-name ui-managed-instance \\ --desired-count 2 \\ --task-definition retail-store-ecs-ui-managed \\ --load-balancers targetGroupArn=arn:aws:elasticloadbalancing:ap-northeast-2:${ACCOUNT_ID}:targetgroup/ui-managed-tg/57dad0b464a5ef76,containerName=application,containerPort=8080 \\ --capacity-provider-strategy capacityProvider=retail-store-managed-instances-cp,weight=1 \\ --network-configuration \u0026#34;awsvpcConfiguration={subnets=[${PRIVATE_SUBNET1}, ${PRIVATE_SUBNET2}], securityGroups=[${UI_SG_ID}],assignPublicIp=DISABLED}\u0026#34; Check Service information on ECS Console:\nRun the following command to review configuration of running tasks. You will see CapacityProviderName is now retail-store-managed-instances-cp instead of FARGATE:\naws ecs describe-tasks \\ --cluster retail-store-ecs-cluster \\ --tasks $(aws ecs list-tasks --cluster retail-store-ecs-cluster --service ui-managed-instance --query \u0026#39;taskArns[]\u0026#39; --output text) \\ --query \u0026#34;tasks[*].{Group:group, CapacityProviderName:capacityProviderName, LastStatus:lastStatus, HealthStatus:healthStatus, TaskArn:taskArn}\u0026#34; --output table You can get load balancer URL on AWS Console as follows:\nAccess the load balancer URL to check and you can see the website has been deployed successfully.\n"
},
{
	"uri": "http://localhost:1313/7-networking/7.2-service-connect/",
	"title": "ECS Service Connect",
	"tags": [],
	"description": "",
	"content": "ECS Service Connect is the recommended method for handling communication between services (service-to-service communication), providing features such as service discovery, connectivity, and traffic monitoring.\nWith Service Connect, your applications can use short names and standard ports to connect to ECS services in the same cluster, different clusters, different VPCs, and even between AWS Accounts in the same AWS Region. For more detailed information, please refer to AWS Documentation.\nAlternatives to configure inter-service communication in Amazon ECS Services include:\nInternal Load Balancer\nService Discovery\nAmazon VPC Lattice\n"
},
{
	"uri": "http://localhost:1313/2-fundamentals/",
	"title": "Fundamentals",
	"tags": [],
	"description": "",
	"content": "Amazon ECS Core Components Amazon ECS has 4 main components:\nCluster: The central management space in Amazon ECS, where all application services and tasks are organized and operated.\nService: Represents a group of identical tasks, responsible for maintaining the desired number of tasks running correctly, while supporting automatic restart or scaling when needed.\nTask: The execution unit in ECS, consisting of one or more containers working together to perform a specific function of the application.\nTask Definition: A detailed description of how a task is run, including information such as CPU, memory, container image, network configuration, IAM role, and other necessary settings.\nUnderstanding these components is very important for using Amazon ECS effectively in managing containerized applications. Each component plays a key role in the overall architecture and operation of ECS deployments.\nLayers There are 3 Layers in ECS:\nCapacity: Infrastructure where Containers run.\nController: Deploy and manage applications running on Containers.\nProvisioning: Tools to interact with scheduler to deploy and manage applications and containers.\nCapacity Capacity (compute capacity) is the infrastructure where containers run. Below is an overview of capacity options:\nAmazon ECS Managed Instances Amazon ECS Managed Instances is a compute option for Amazon ECS, allowing you to run containerized workloads on various Amazon EC2 instance types, while delegating most infrastructure management to AWS.\nWith Amazon ECS Managed Instances, you can:\nGPU acceleration. Specific CPU architecture. High network performance. Dedicated instance types. Meanwhile, AWS will be responsible for:\nInfrastructure provisioning. Operating system patching. Scaling. Maintenance and operation of underlying infrastructure. Amazon EC2 Instances You can choose instance type and number of instances yourself. Self-manage Capacity (Auto Scaling, patching, lifecycle, etc.). Serverless AWS Fargate is a serverless compute engine, pay-as-you-go. With Fargate: No need to manage servers. No need to plan capacity. No need to isolate container workloads yourself as AWS handles security. Server/VM On-Premises Amazon ECS Anywhere registers external instances (on-premises servers or VMs). Connect them to ECS cluster. Amazon ECS Scheduler Amazon ECS Scheduler is software responsible for managing and orchestrating your applications, including: Deciding where tasks run. Managing task lifecycle. Ensuring service desired state. "
},
{
	"uri": "http://localhost:1313/6-auto-scaling/6.2-target_tracking_scaling/",
	"title": "Target Tracking Scaling",
	"tags": [],
	"description": "",
	"content": "Register Scalable Target In this section, we will configure ECS Service Auto Scaling using Target Tracking Scaling.\nFirst, Register UI service as a scalable target with Application Auto Scaling. The following command sets scaling range for UI Service from minimum 2 to maximum 10 tasks.\nThe register-scalable-target command is used to allow ECS Service to be auto scaled and limit the scale range (min/max tasks); without this step, all scaling policies are invalid.\naws application-autoscaling register-scalable-target \\ --service-namespace ecs \\ --scalable-dimension ecs:service:DesiredCount \\ --resource-id service/retail-store-ecs-cluster/ui \\ --min-capacity 2 \\ --max-capacity 10 Scalable Target is an object that can be Auto Scaled. This declaration tells Application Auto Scaling: \u0026ldquo;This ECS Service IS ALLOWED to auto scale, and can only scale within a specified range.\u0026rdquo;\nCreate Scaling Policy Scaling policy is a set of rules that determine when and how Amazon ECS Service will increase or decrease the number of tasks, based on monitored metrics.\nScaling policy does not directly perform resource scaling, but:\nMonitors metrics from CloudWatch Compares metrics with configured conditions or targets Sends requests to Application Auto Scaling to adjust DesiredCount of ECS Service In Amazon ECS:\nScaling policy is managed by Application Auto Scaling The object being scaled is DesiredCount of ECS Service Next, we will create a scaling policy for this scalable target.\nFirst, create a JSON configuration file for scaling policy. This configuration uses predefined metric type of request count per target related to Application Load Balancer (ALB) routing requests to ECS service. In this case, our target is 1,500 requests for each ECS task (or target).\nThis scaling policy is for example purposes only. You need to understand the specific workload\u0026rsquo;s scaling profile to determine appropriate scaling metrics and thresholds before enabling autoscaling.\nJSON configuration file ui-scaling-policy.json:\n{ \u0026#34;TargetValue\u0026#34;: 1500, \u0026#34;PredefinedMetricSpecification\u0026#34;: { \u0026#34;PredefinedMetricType\u0026#34;: \u0026#34;ALBRequestCountPerTarget\u0026#34;, \u0026#34;ResourceLabel\u0026#34;: \u0026#34;$UI_ALB_PREFIX/$UI_TG_PREFIX\u0026#34; } } Note that we are using environment variables $UI_ALB_PREFIX and $UI_TG_PREFIX to specify the correct ALB and Target Group for UI service.\n$UI_ALB_PREFIX: ARN of ALB, however only the prefix part is needed. Example: app/ecs-workshop-alb/07eeccd166f4ef38 $UI_TG_PREFIX: Target Group prefix for UI service. Example: targetgroup/ui-tg/2feb79f68add27c7 Now, the ResourceLabel in the JSON configuration file is as follows: app/ecs-workshop-alb/07eeccd166f4ef38/targetgroup/ui-tg/2feb79f68add27c7\naws application-autoscaling put-scaling-policy \\ --service-namespace ecs \\ --scalable-dimension ecs:service:DesiredCount \\ --resource-id service/retail-store-ecs-cluster/ui \\ --policy-name ui-scaling-policy \\ --policy-type TargetTrackingScaling \\ --target-tracking-scaling-policy-configuration file://ui-scaling-policy.json Check target tracking scaling policy in Amazon ECS console.\nCloudWatch Alarm Alarm state can change depending on the number of requests. For example, UI-AlarmLow will trigger when the number of requests drops below 1350.\nHigh Alarm Configuration (Scale-out):\nMetric: ALBRequestCountPerTarget \u0026gt; 1500\nEvaluation: 3 data points in 3 minutes\nAction: When in ALARM state, will add tasks to ECS service\nBehavior: Continue adding tasks in subsequent evaluation periods if alarm still exists, up to the limit specified in scaling policy\nLow Alarm Configuration (Scale-in):\nMetric: ALBRequestCountPerTarget \u0026lt; 1350\nEvaluation: 15 data points in 15 minutes\nAction: When in ALARM state, will reduce number of tasks\nBehavior: Scale-in slower to prioritize high availability\nTrigger Auto Scaling Proceed to create synthetic load to trigger auto scaling.\nFirst we need to get DNS Name of Application Load Balancer attached to UI service.\nexport RETAIL_ALB=$(aws elbv2 describe-load-balancers --name ecs-workshop-alb \\ --query \u0026#39;LoadBalancers[0].DNSName\u0026#39; --output text) echo \u0026#34;Retail ALB: ${RETAIL_ALB}\u0026#34; Next, we will use hey tool to send requests to the /home path of UI service:\nYou can install hey tool with the following command:\nsudo apt update sudo apt install hey -y hey -n 1000000 -c 5 -q 40 http://$RETAIL_ALB/home \u0026amp; Scaling activity will be triggered when high alarm for scaling metric is breached in 3 consecutive cycles, each cycle 1 minute. If you want to automatically wait until the alarm is triggered, you can run the following command (approximately ~ 4 minutes):\nsleep 90 \u0026amp;\u0026amp; aws cloudwatch wait alarm-exists --alarm-name-prefix \\ TargetTracking-service/retail-store-ecs-cluster/ui-AlarmHigh --state-value ALARM When the alarm is triggered, you will see task count of service scale out from 2 to a higher number:\naws ecs describe-tasks \\ --cluster retail-store-ecs-cluster \\ --tasks $(aws ecs list-tasks --cluster retail-store-ecs-cluster --query \u0026#39;taskArns[]\u0026#39; --output text) \\ --query \u0026#34;tasks[*].[group, launchType, lastStatus, healthStatus, taskArn]\u0026#34; --output table You can observe the high alarm related to scaling policy change to ALARM state in CloudWatch console, as shown below.\nYou can also check the Events tab in the UI Service page to see scaling activity, where desired count increases beyond the initial number of tasks.\nNext we will proceed to reduce the number of tasks in ECS service.\nStop Hey process:\npkill -9 hey Normally, after a few minutes, the number of tasks will scale back to the minimum of 2. However, to save time, we can force scale down the service by running the following commands:\naws ecs wait services-stable --cluster retail-store-ecs-cluster --services ui aws ecs update-service \\ --cluster retail-store-ecs-cluster \\ --service ui \\ --task-definition retail-store-ecs-ui \\ --desired-count 2 "
},
{
	"uri": "http://localhost:1313/5-managed-instances/5.3-managed/",
	"title": "Managed Instances Infrastructure",
	"tags": [],
	"description": "",
	"content": "Managed Instances Infrastructure In this section, we will dive deeper into the EC2 instances that Amazon ECS Managed Instances has created to support the UI service we deployed in the previous section.\nRun the following command to view EC2 instances:\naws ec2 describe-instances \\ --filters \\ \u0026#34;Name=tag:aws:ec2:managed-launch,Values=ecs-managed-instances\u0026#34; \\ \u0026#34;Name=instance-state-name,Values=running\u0026#34; \\ --query \u0026#39;Reservations[*].Instances[*].{InstanceId:InstanceId,InstanceType:InstanceType,State:State.Name,PrivateIpAddress:PrivateIpAddress}\u0026#39; \\ --output table Since UI service is deployed in high-availability (HA) model with 2 running tasks, and Amazon ECS Managed Instance capacity provider is attached to 2 subnets (in different AZs), you will see 2 different EC2 instances running.\nYou can see different EC2 instance types running in the cluster, because we did not specify any conditions in the capacity provider for Amazon ECS Managed Instances.\n------------------------------------------------------------------------\r| DescribeInstances |\r+----------------------+---------------+--------------------+----------+\r| InstanceId | InstanceType | PrivateIpAddress | State |\r+----------------------+---------------+--------------------+----------+\r| i-056556a991639db3c | c5a.large | 10.0.145.243 | running |\r| i-08b1aa2b2ec697a12 | c5a.large | 10.0.135.156 | running |\r+----------------------+---------------+--------------------+----------+ You can view Instances on ECS Console:\nNow, let\u0026rsquo;s check how Amazon ECS Managed Instance handles additional workload by increasing the number of running tasks of UI service from 2 to 6. In this case, you will notice that because current EC2 instances do not have enough resources to deploy the running tasks, additional EC2 instances will be deployed to support the expanded workload. See AWS Documentation for more information on instance selection.\naws ecs update-service \\ --cluster retail-store-ecs-cluster \\ --service ui-managed-instance \\ --desired-count 6 \\ --placement-constraints \\ --task-definition retail-store-ecs-ui-managed After the deployment process completes, let\u0026rsquo;s see how tasks are distributed across EC2 instances.\nYou can see there are 2 tasks running on m7i-flex.large and 2 tasks running on m5.large with the remaining 2 tasks evenly distributed to c5a.large.\nCheck instance types by opening EC2 console to view new EC2 instances. Amazon ECS Managed Instance will initialize additional instances to meet new capacity requirements.\nFinally, scale down the number of tasks of UI service to 2.\naws ecs update-service \\ --cluster retail-store-ecs-cluster \\ --service ui-managed-instance \\ --desired-count 2 \\ --task-definition retail-store-ecs-ui-managed \\ --placement-constraints type=\u0026#34;distinctInstance\u0026#34; 4 tasks have been removed and there are now 2 instances in idle state.\nAfter a few more minutes, idle instances will be deregistered and terminated by the capacity provider. Execute the following command, after a few minutes you will only see 2 EC2 instances running:\naws ec2 describe-instances \\ --filters \\ \u0026#34;Name=tag:aws:ec2:managed-launch,Values=ecs-managed-instances\u0026#34; \\ \u0026#34;Name=instance-state-name,Values=running\u0026#34; \\ --query \u0026#39;Reservations[*].Instances[*].{InstanceId:InstanceId,InstanceType:InstanceType,State:State.Name,PrivateIpAddress:PrivateIpAddress}\u0026#39; \\ --output table "
},
{
	"uri": "http://localhost:1313/3-prepare/",
	"title": "Preparation",
	"tags": [],
	"description": "",
	"content": "In this section, you will perform the necessary preparation steps to be ready for the following practice sections. These preparation steps will help you set up the environment and basic configuration to deploy and manage containerized applications on Amazon ECS.\nIn this Preparation section, you will:\n3.1 - Create User \u0026amp; Access Key\nInstall and configure AWS CLI Create IAM User with AdministratorAccess permissions Create Access Key to authenticate with AWS services 3.2 - Create Cluster \u0026amp; Task Definition\nCreate Amazon ECS Cluster with CloudWatch Container Insights Define Task Definitions with CPU, memory parameters and container specifications 3.3 - Services\nCreate VPC and configure networking (subnets, NAT Gateway) Deploy and manage ECS Services to maintain desired number of tasks 3.4 - Update Services\nUpdate services with new configuration and deployments Use environment variables to configure applications "
},
{
	"uri": "http://localhost:1313/6-auto-scaling/6.3-scheduled_scaling/",
	"title": "Scheduled Scaling",
	"tags": [],
	"description": "",
	"content": "\rYou must complete the Target Tracking Scaling section before proceeding with this section.\nIn this section, we will configure ECS Service Auto Scaling using Scheduled Scaling. This includes setting up scaling rules based on fixed schedules, suitable for services with predictable load patterns.\nWe will create a scheduled scaling for the UI service using cron expression (auto scaling schedule) to test scale-out and scale-in by adjusting the minimum value.\nRun the following command to increase minimum capacity from 2 to 5 after 1 minute from the current time.\naws application-autoscaling put-scheduled-action \\ --service-namespace ecs \\ --scalable-dimension ecs:service:DesiredCount \\ --resource-id service/retail-store-ecs-cluster/ui \\ --scheduled-action-name \u0026#34;test-scale-up\u0026#34; \\ --schedule \u0026#34;at($(date -u -d \u0026#34;+1 minutes\u0026#34; \u0026#34;+%Y-%m-%dT%H:%M:%S\u0026#34;))\u0026#34; \\ --scalable-target-action MinCapacity=5,MaxCapacity=10 You need to register a scalable target before creating scheduled scaling.\nCheck Event:\nRun the following command to observe the scheduled action. You will see a list of 5 ECS tasks.\naws ecs describe-tasks \\ --cluster retail-store-ecs-cluster \\ --tasks $(aws ecs list-tasks --cluster retail-store-ecs-cluster --service-name ui --query \u0026#39;taskArns[]\u0026#39; --output text) \\ --query \u0026#34;tasks[*].[group, launchType, lastStatus, healthStatus, taskArn]\u0026#34; --output table Check on ECS Consle:\nNow run the following command to scale back. This command will set the desired capacity to 2, which is the initial task level.\naws ecs update-service \\ --cluster retail-store-ecs-cluster \\ --service ui \\ --task-definition retail-store-ecs-ui \\ --desired-count 2 Check on ECS Consle:\nDeploying Scheduled Scaling in Practice The commands can be adjusted to schedule scaling in the necessary time frames based on application requirements. For example, scheduled scaling can be configured to trigger at 9 AM UTC and 6 PM UTC daily, suitable for peak hours of a global application.\nThe following example can be applied in practice.\nThe following command will trigger scale-out, increasing the number of tasks to 5 every day at 9:00 AM UTC to handle expected high traffic during the day:\naws application-autoscaling put-scheduled-action \\ --service-namespace ecs \\ --scalable-dimension ecs:service:DesiredCount \\ --resource-id service/retail-store-ecs-cluster/ui \\ --scheduled-action-name \u0026#34;week-day-scale-out\u0026#34; \\ --schedule \u0026#34;cron(0 9 ? * MON-FRI *)\u0026#34; \\ --scalable-target-action MinCapacity=5,MaxCapacity=10 The following command will trigger scale-in, reducing the number of tasks during off-peak hours. For example, we will scale down the UI service at 6 PM every day.\naws application-autoscaling put-scheduled-action \\ --service-namespace ecs \\ --scalable-dimension ecs:service:DesiredCount \\ --resource-id service/retail-store-ecs-cluster/ui \\ --scheduled-action-name \u0026#34;week-day-scale-in\u0026#34; \\ --schedule \u0026#34;cron(0 18 ? * MON-FRI *)\u0026#34; \\ --scalable-target-action MinCapacity=2,MaxCapacity=10 "
},
{
	"uri": "http://localhost:1313/3-prepare/3.3-services/",
	"title": "Services",
	"tags": [],
	"description": "",
	"content": "Create VPC Access VPC on AWS Console:\nSelect Create VPC.\nSelect VPC and more and configure the following parameters:\nVPC Name: ecs-workshop VPC CIDR Block: 10.0.0.0/16 Number of Availability Zones: 2 Number of Public Subnets: 2 Number of Private Subnets: 2 NAT Gateway: None (NAT will be created manually later) VPC Endpoint: None After configuration is complete, select Create VPC.\nThe VPC has been created successfully.\nCreate NAT Gateway On VPC Console interface, select NAT Gateways and select Create NAT Gateway.\nConfigure the following parameters:\nNAT Gateway Name: ecs-workshop-nat Availability mode: Regional VPC: The VPC just created. Method of Elastic IP (EIP) allocation: Automatic After configuration is complete, proceed to select Create NAT Gateway\nProceed to create Elastic IP on VPC Console interface.\nSelect Allocation Elastic IP address Select Allocate\nThe Elastic IP has been created successfully.\nNAT Gateway will automatically take the created Elastic IP.\nAfter creating NAT Gateway, proceed to configure Route Table for Private Subnet.\nAccess Route Table:\nSelect Private Subnet. Select Routes Select Edit Routes Configure the following parameters:\nDestination: 0.0.0.0/0 Target: NAT Gateway and select the ID of the NAT Gateway just created. The Route Table has been configured successfully.\nDo the same for the second Private Subnet.\nCreate Security Group Access EC2 Console:\nSelect Security Groups and select Create Security Group.\nWe will proceed to create alb-sg to allow access to ALB.\nSecurity Group Name: alb-sg Description: Security Group for ALB VPC: The VPC just created. Inbound rules:\nType: HTTP Port: 80 Source: 0.0.0.0/0 Type: HTTPS Port: 443 Source: 0.0.0.0/0 Outbound rules:\nType: All traffic Source: 0.0.0.0/0 After configuration is complete, proceed to select Create Security Group\nAfter creating Security Group for ALB, proceed to create Security Group for application.\nSecurity Group Name: ui-sg Description: Security Group for UI VPC: The VPC just created. Inbound rules:\nType: Custom TCP Rule Port: 8080 Source: alb-sg After configuration is complete, proceed to select Create Security Group\nThe Security Group has been created successfully.\nCreate Target Group Access EC2 Console:\nSelect Target Groups section and select Create Target Group.\nConfigure the following parameters:\nTarget Group Name: ui-tg Target Type: IP Addresses Protocol: HTTP Port: 8080 VPC: The VPC just created. Health Check Protocol: HTTP Health Check Path: /actuator/health After configuration is complete, select Next.\nSelect Next.\nReview the parameters and select Create Target Group.\nThe Target Group has been created successfully.\nCreate Application Load Balancer On EC2 Console interface, select Load Balancers and select Create Load Balancer.\nSelect Type as Application Load Balancer.\nConfigure the following parameters:\nLoad Balancer Name: ecs-workshop-alb Scheme: Internet-facing VPC: The VPC just created. Configure 2 Public Subnets for ALB. Select alb-sg just created. Review and select Create Load Balancer.\nCreate ECS Service After creating the above components, proceed to create ECS Service.\nUse the following CLI to create ECS Service.\nNote the following parameters:\nUI_TG_ARN: ARN of the application\u0026rsquo;s Target Group. PRIVATE_SUBNET1: ID of the first Private Subnet. PRIVATE_SUBNET2: ID of the second Private Subnet. UI_SG_ID: ID of the application\u0026rsquo;s Security Group. aws ecs create-service \\ --cluster retail-store-ecs-cluster \\ --service-name ui \\ --task-definition retail-store-ecs-ui \\ --desired-count 2 \\ --launch-type FARGATE \\ --load-balancers targetGroupArn=${UI_TG_ARN},containerName=application,containerPort=8080 \\ --network-configuration \u0026#34;awsvpcConfiguration={subnets=[${PRIVATE_SUBNET1},${PRIVATE_SUBNET2}],securityGroups=[${UI_SG_ID}],assignPublicIp=DISABLED}\u0026#34; Access the Cluster to check and you can see the Service has been created successfully.\nCheck Service information:\nCheck Task information:\nWe can see 2 Tasks have been created successfully.\nProceed to access the Web with ALB URL to check the website.\nhttp://ecs-workshop-alb-653740503.ap-northeast-2.elb.amazonaws.com\nThe application has been deployed successfully.\nAfter creating the basic components, the current architecture of the configured Services is displayed below.\n"
},
{
	"uri": "http://localhost:1313/4-express-mode/",
	"title": "Express Mode",
	"tags": [],
	"description": "",
	"content": "\rYou must complete the following chapters before performing this lab: 3. Preparation\nIn this section, we will learn about Amazon ECS Express Mode â€” a simplified container deployment solution that allows developers to launch containerized applications with High Availability and Scalability with just a single command.\nBy automating infrastructure setup and following AWS best practices, ECS Express Mode eliminates the complexity of container orchestration, while still maintaining full access to Amazon ECS capabilities when needed.\nThis helps development teams focus on building applications, instead of having to manage infrastructure components such as load balancing, auto-scaling, and networking.\nBenefits of Amazon ECS Express Mode Simple deployment: Deploy with production-ready default configurations with just one command.\nNo capability limitations: Still have full access to underlying AWS resources when needed.\nCost optimization: Share Application Load Balancer between services to reduce costs.\nTransparent infrastructure: All resources are clearly visible and accessible in your AWS account.\n"
},
{
	"uri": "http://localhost:1313/3-prepare/3.4-updated_services/",
	"title": "Update Services",
	"tags": [],
	"description": "",
	"content": "In this section we will update an ECS Service. This process is commonly used in situations such as changing container image or adjusting application configuration.\nEnvironment variables are one of the main mechanisms to configure workloads running in containers, regardless of which Orchestrator is used. We will proceed to change the configuration of UI Service to use new environment variables.\nDocker Image cannot be changed after being built, so environment variables are a simple and flexible way to configure and adjust application behavior when the container is running.\nIn this case, we will use the RETAIL_UI_THEME variable, which will change the default interface color of the application.\nDeclare variables in Task Definition Environment variables in ECS task definition are declared as name-value pairs, for example:\n\u0026#34;environment\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_UI_THEME\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;green\u0026#34; } ] Next, proceed to update the json file retail-store-ecs-ui-updated-taskdef.json with the new environment variable.\n{ \u0026#34;family\u0026#34;: \u0026#34;retail-store-ecs-ui\u0026#34;, \u0026#34;executionRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/retailStoreEcsTaskExecutionRole\u0026#34;, \u0026#34;taskRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/retailStoreEcsTaskRole\u0026#34;, \u0026#34;networkMode\u0026#34;: \u0026#34;awsvpc\u0026#34;, \u0026#34;requiresCompatibilities\u0026#34;: [ \u0026#34;FARGATE\u0026#34; ], \u0026#34;cpu\u0026#34;: \u0026#34;1024\u0026#34;, \u0026#34;memory\u0026#34;: \u0026#34;2048\u0026#34;, \u0026#34;runtimePlatform\u0026#34;: { \u0026#34;cpuArchitecture\u0026#34;: \u0026#34;X86_64\u0026#34;, \u0026#34;operatingSystemFamily\u0026#34;: \u0026#34;LINUX\u0026#34; }, \u0026#34;containerDefinitions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;public.ecr.aws/aws-containers/retail-store-sample-ui:1.2.3\u0026#34;, \u0026#34;portMappings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;containerPort\u0026#34;: 8080, \u0026#34;hostPort\u0026#34;: 8080, \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;appProtocol\u0026#34;: \u0026#34;http\u0026#34; } ], \u0026#34;essential\u0026#34;: true, \u0026#34;linuxParameters\u0026#34;: { \u0026#34;initProcessEnabled\u0026#34;: true }, \u0026#34;environment\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_UI_THEME\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;green\u0026#34; } ], \u0026#34;healthCheck\u0026#34;: { \u0026#34;command\u0026#34;: [ \u0026#34;CMD-SHELL\u0026#34;, \u0026#34;curl -f http://localhost:8080/actuator/health || exit 1\u0026#34; ], \u0026#34;interval\u0026#34;: 10, \u0026#34;timeout\u0026#34;: 5, \u0026#34;retries\u0026#34;: 3, \u0026#34;startPeriod\u0026#34;: 60 }, \u0026#34;logConfiguration\u0026#34;: { \u0026#34;logDriver\u0026#34;: \u0026#34;awslogs\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;awslogs-group\u0026#34;: \u0026#34;retail-store-ecs-tasks\u0026#34;, \u0026#34;awslogs-region\u0026#34;: \u0026#34;$AWS_REGION\u0026#34;, \u0026#34;awslogs-stream-prefix\u0026#34;: \u0026#34;ui-service\u0026#34; } } } ] } Then, use the register-task-definition command to register the new task definition:\naws ecs register-task-definition \\ --cli-input-json file://retail-store-ecs-ui-updated-taskdef.json ECS task definition is immutable, meaning it cannot be edited after creation. Instead, the above command will create a new revision, which is a copy of the old task definition but with updated new parameters.\nCheck Task Definition revisions You can check how many revisions currently exist with the command:\naws ecs list-task-definitions --family-prefix retail-store-ecs-ui --sort DESC --max-items 2 The result will display the revisions of the UI task definition:\n{ \u0026#34;taskDefinitionArns\u0026#34;: [ \u0026#34;arn:aws:ecs:us-west-2:XXXXXXXXXXXX:task-definition/retail-store-ecs-ui:2\u0026#34;, \u0026#34;arn:aws:ecs:us-west-2:XXXXXXXXXXXX:task-definition/retail-store-ecs-ui:1\u0026#34; ] } Or you can check directly on AWS Console:\nUpdate ECS Service to use new revision Next, update ECS service to use the new task definition:\naws ecs update-service --cluster retail-store-ecs-cluster --service ui --task-definition retail-store-ecs-ui Check results "
},
{
	"uri": "http://localhost:1313/5-managed-instances/",
	"title": "ECS Managed Instances",
	"tags": [],
	"description": "",
	"content": "Amazon ECS Managed Instances is a fully managed compute option that eliminates the burden of infrastructure management while still providing access to the rich EC2 ecosystem, including:\nFlexibility to choose instance type Access to reserved capacity Advanced security and observability configuration By delegating operational tasks to AWS, ECS Managed Instances helps you get started faster and reduces total cost of ownership (TCO).\nBenefits of Amazon ECS Managed Instances Accelerate innovation: Delegate infrastructure management and patching to AWS, thereby significantly reducing operational overhead.\nImprove performance and availability: Enhance performance and availability through flexibility to choose instance type suitable for each workload and leverage reserved capacity.\nOptimize costs: Optimize costs through automatic instance configuration, capacity management, and intelligent workload allocation.\nImprove application security: Allows advanced security and observability configuration for applications.\nSee AWS Documentation for more information about Amazon ECS Managed Instances.\n"
},
{
	"uri": "http://localhost:1313/3-prepare/3.5-enable_ecs_exec/",
	"title": "Enable ECS Exec",
	"tags": [],
	"description": "",
	"content": "In this section we will enable ECS Exec feature to be able to run commands or open shell directly into containers running on EC2 instances or Fargate.\nEnabling ECS Exec brings many benefits for operational management and is especially good for security. This feature allows controlled access to containers running in ECS tasks, helping to troubleshoot safely, with audit, without needing SSH into the host.\nBy leveraging IAM policies and IAM roles, you can tightly control who is allowed to execute commands inside containers, thereby enhancing the overall security posture of the system.\nAdditionally, all commands executed through ECS Exec are logged to CloudWatch, helping to create an audit trail for monitoring and compliance purposes.\nSet IAM Role for User This is the step to set permissions for User to be able to use ECS Exec. If following this lab, we have configured User with AdministratorAccess permissions, so this step can be skipped.\nProceed to create Policy with the following permissions:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;ecs:ExecuteCommand\u0026#34;, \u0026#34;ecs:DescribeTasks\u0026#34; ], \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:ecs:${AWS_REGION}:${ACCOUNT_ID}:task/retail-store-ecs-cluster/*\u0026#34;, \u0026#34;arn:aws:ecs:${AWS_REGION}:${ACCOUNT_ID}:cluster/*\u0026#34; ] } ] } Add the above json to file ecs-exec-command-policy.json and run the following command:\naws iam put-role-policy --role-name $(aws sts get-caller-identity --query \u0026#39;Arn\u0026#39; | cut -d\u0026#39;/\u0026#39; -f2) --policy-name AmazonECSExecCommand --policy-document file://ecs-exec-command-policy.json Set IAM Role for ECS Task Role ECS Exec requires task IAM role to communicate with AWS Systems Manager (SSM).\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;ssmmessages:CreateControlChannel\u0026#34;, \u0026#34;ssmmessages:CreateDataChannel\u0026#34;, \u0026#34;ssmmessages:OpenControlChannel\u0026#34;, \u0026#34;ssmmessages:OpenDataChannel\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Add the above json to file ecs-exec-task-role-policy.json and run the following command:\naws iam put-role-policy --role-name retailStoreEcsTaskRole --policy-name AmazonECSExecTaskRolePolicy --policy-document file://ecs-exec-task-role-policy.json Check the Policy of the role just created\naws iam list-role-policies --role-name retailStoreEcsTaskRole --query \u0026#39;PolicyNames[0]\u0026#39; --output text Check role permissions with the following command:\naws iam get-role-policy --role-name retailStoreEcsTaskRole --policy-name AmazonECSExecTaskRolePolicy Prepare environment Install necessary tools:\nAWS CLI. Session Manager plugin for AWS CLI. We have already installed AWS CLI in the Create User and Create Access Key section. Next we will install Session Manager plugin for AWS CLI.\nLinux: curl \u0026#34;https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb\u0026#34; -o \u0026#34;session-manager-plugin.deb\u0026#34; sudo dpkg -i session-manager-plugin.deb MacOS: curl \u0026#34;https://s3.amazonaws.com/session-manager-downloads/plugin/latest/mac/session-manager-plugin.pkg\u0026#34; -o \u0026#34;session-manager-plugin.pkg\u0026#34; sudo installer -pkg session-manager-plugin.pkg -target / sudo ln -s /usr/local/sessionmanagerplugin/bin/session-manager-plugin /usr/local/bin/session-manager-plugin Windows: https://s3.amazonaws.com/session-manager-downloads/plugin/latest/windows/SessionManagerPluginSetup.exe Run the following command to check Session Manager plugin has been installed successfully:\nsession-manager-plugin Enable ECS Exec on Service Update UI Service to enable ECS Exec by using the --enable-execute-command flag:\naws ecs update-service \\ --cluster retail-store-ecs-cluster \\ --service ui \\ --task-definition retail-store-ecs-ui \\ --enable-execute-command --force-new-deployment Check ARN of ECS task with ECS Exec enabled Run the following command to select a running UI task with enableExecuteCommand = true:\nECS_EXEC_TASK_ARN=$(aws ecs list-tasks --cluster retail-store-ecs-cluster \\ --service-name ui --query \u0026#39;taskArns[]\u0026#39; --output text | \\ xargs -n1 aws ecs describe-tasks --cluster retail-store-ecs-cluster --tasks | \\ jq -r \u0026#39;.tasks[] | select(.enableExecuteCommand == true) | .taskArn\u0026#39; | \\ head -n 1) Check the result by running the echo command:\necho $ECS_EXEC_TASK_ARN Connect to ECS Task Proceed to connect to ECS Task by running the following command:\nif [ -z \u0026#34;${ECS_EXEC_TASK_ARN}\u0026#34; ]; then echo \u0026#34;ECS_EXEC_TASK_ARN is not correctly configured!\u0026#34; else aws ecs execute-command \\ --cluster retail-store-ecs-cluster \\ --task $ECS_EXEC_TASK_ARN \\ --container application \\ --interactive \\ --command \u0026#34;/bin/bash\u0026#34; fi We will see Output as below:\nThe Session Manager plugin was installed successfully. Use the AWS CLI to start a session. Starting session with SessionId: ecs-execute-command-vvdysulqbcz2txr2d262sw2s64 bash-5.2# "
},
{
	"uri": "http://localhost:1313/6-auto-scaling/",
	"title": "Auto Scaling",
	"tags": [],
	"description": "",
	"content": "Since a Fargate instance corresponds to one ECS task, you need to specify CPU and memory of the task when creating task definition. Therefore, right-sizing Fargate tasks is very important to ensure they can perform tasks with desired performance levels.\nIf a task encounters difficulties due to insufficient CPU or memory, this indicates the task has not been sized correctly and may need additional resources. You can accurately assess application needs through performance measurement, comprehensive load testing, or closely monitoring key metrics.\nOnce you are certain that tasks are properly sized, you can scale horizontally by deploying additional tasks to handle more requests. Horizontal scaling is the preferred method to scale cloud-native, containerized workloads.\nService Auto Scaling Amazon ECS provides the ability to automatically adjust desired number of tasks in a service, this feature is called Service Auto Scaling.\nECS Service Auto Scaling uses Application Auto Scaling to provide this functionality. For auto scaling to work effectively, the metric used must be a proportional metric. If you keep the number of tasks in the service constant and load doubles, then the metric value must also double.\nProportional metric is a metric that increases/decreases proportionally with system load.\nIn the context of ECS when using EC2 instances, you also need to consider using capacity providers to manage capacity of EC2 instances alongside ECS Service Auto Scaling. However, since this lab section primarily focuses on Fargate, we will not go deep into ECS capacity providers in this section.\n"
},
{
	"uri": "http://localhost:1313/7-networking/",
	"title": "Networking",
	"tags": [],
	"description": "",
	"content": "The current application is built from multiple distributed components (microservices) communicating with each other. For example, the UI component communicates via API with the Checkout component, which is linked to a persistent storage layer using Redis, as illustrated in the architecture diagram below. At the same time, both UI and Checkout communicate via API with the Orders service, which uses PostgreSQL as the data storage layer.\nIn this section we will learn about ECS Networking and how it works related to Fargate.\n"
},
{
	"uri": "http://localhost:1313/8-observability/",
	"title": "Observability",
	"tags": [],
	"description": "",
	"content": "Observability "
},
{
	"uri": "http://localhost:1313/9-security/",
	"title": "Security",
	"tags": [],
	"description": "",
	"content": "Security "
},
{
	"uri": "http://localhost:1313/10-deployments/",
	"title": "Deployments",
	"tags": [],
	"description": "",
	"content": "Deployments "
},
{
	"uri": "http://localhost:1313/11-storage/",
	"title": "Storage",
	"tags": [],
	"description": "",
	"content": "Storage "
},
{
	"uri": "http://localhost:1313/12-cost-optimizations/",
	"title": "Cost Optimizations",
	"tags": [],
	"description": "",
	"content": "Cost Optimizations "
},
{
	"uri": "http://localhost:1313/13-clean-up/",
	"title": "Clean Up",
	"tags": [],
	"description": "",
	"content": "Clean Up "
},
{
	"uri": "http://localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]