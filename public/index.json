[
{
	"uri": "//localhost:1313/3-prepare/3.1-user_accesskey/",
	"title": "Create User &amp; Access Key",
	"tags": [],
	"description": "",
	"content": "Install AWS CLI Linux: sudo apt update sudo apt install -y unzip curl curl \u0026#34;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\u0026#34; -o awscliv2.zip unzip awscliv2.zip sudo ./aws/install MacOS: curl \u0026#34;https://awscli.amazonaws.com/AWSCLIV2.pkg\u0026#34; -o AWSCLIV2.pkg sudo installer -pkg AWSCLIV2.pkg -target / Windows: msiexec.exe /i https://awscli.amazonaws.com/AWSCLIV2.msi Create User and Access Key Access AWS Console and create a new User with AdministratorAccess permissions.\nIn the AWS Console search bar, type \u0026ldquo;IAM\u0026rdquo; and select \u0026ldquo;IAM\u0026rdquo;.\nSelect Users in the left menu.\nNext, select Add user to create a new User.\nEnter a name for the User: ecs-workshop\nSelect Custom Password to create a password for the User.\nSelect Next.\nConfigure permissions for the User:\nAttach policies directly: Select AdministratorAccess to configure permissions for the User. Select Next.\nSelect Create user.\nThe User has been created successfully.\nReturn to the IAM Console and select Users in the left menu.\nSelect the User you just created.\nSelect the Security credentials tab.\nSelect Create access key.\nSelect Command Line Interface (CLI). Confirm and proceed to the next step.\nDescription: Amazon ECS Immersion Day and proceed to create the access key.\nThe access key has been created successfully and you can click Download .csv to download the credentials.csv file.\nConfigure AWS CLI Access the CLI to configure AWS CLI.\nCheck the AWS CLI version.\naws --version Configure AWS CLI.\naws configure AWS CLI has been configured successfully.\nTest AWS CLI functionality.\naws ec2 describe-instances AWS CLI has been configured successfully and is working properly.\n"
},
{
	"uri": "//localhost:1313/1-introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Amazon ECS Amazon Elastic Container Service (ECS) is a fully managed container orchestration service by AWS that simplifies deploying, managing, and scaling containerized applications. This service integrates closely with other AWS services, providing a secure and easy-to-use solution for running container workloads in the cloud and on-premises infrastructure through Amazon ECS Anywhere.\nAWS Fargate AWS Fargate is a serverless compute engine that operates on a pay-as-you-go model, allowing you to focus on building applications without managing servers. AWS Fargate is compatible with both Amazon Elastic Container Service (Amazon ECS) and Amazon Elastic Kubernetes Service (Amazon EKS).\nBenefits of AWS Fargate Focus on applications, not infrastructure: Deploy and manage applications without handling operational tasks such as scaling, patching, security, and server management.\nComprehensive visibility through detailed monitoring: Monitor applications using built-in integrations with AWS services such as Amazon CloudWatch Container Insights, or collect metrics and logs through third-party tools.\nEnhanced security through workload isolation: Enhanced security by design with workload isolation. Each workload running on AWS Fargate uses a separate, single-use, tenant-dedicated compute instance isolated by a virtualization layer. Each Amazon ECS task or Kubernetes pod runs on a newly provisioned instance. For more details on AWS Fargate architecture, refer to AWS Fargate Security Whitepaper.\nCost-effective optimization: Pay only for the compute resources you actually use, with no upfront costs. You can further reduce costs by using Savings Plans, Fargate Spot, or AWS Graviton processors.\nOverview of the Deployed Microservices Application Most labs in this workshop use a Microservices application to provide container components for the exercises. The sample application simulates a simple web store where customers can browse product catalogs, add products to cart, and complete orders through the checkout process.\nThe application includes the following components and dependencies:\nComponent Description UI Provides front-end user interface and aggregates API calls to other Services Catalog API providing product list and details Cart API managing customer shopping cart Checkout API coordinating the entire checkout process Orders API receiving and processing customer orders Containerizing the Application Before deploying a workload to Amazon ECS, that workload needs to be packaged as a container image and published to a container registry.\nBasic container knowledge is not within the scope of this workshop, and the application already has container images available in Amazon Elastic Container Registry (Amazon ECR) for use in the labs.\nThe table below provides the ECR Public repository paths for each component, as well as the Dockerfile used to build each component.\nComponent ECR Public repository Dockerfile UI Repository Dockerfile Catalog Repository Dockerfile Shopping cart Repository Dockerfile Checkout Repository Dockerfile Orders Repository Dockerfile "
},
{
	"uri": "//localhost:1313/",
	"title": "Workshop Amazon Elastic Container Service &amp; AWS Fargate",
	"tags": [],
	"description": "",
	"content": "Workshop Amazon Elastic Container Service \u0026amp; AWS Fargate Welcome to Amazon Elastic Container Service Immersion Day!\nAmazon Elastic Container Service (ECS) is a fully managed Container Orchestration Service by AWS. It allows you to deploy, manage, and scale containerized applications quickly and efficiently.\nECS can integrate with the AWS ecosystem, providing an easy-to-use solution for running containerized workloads in the Cloud environment, while supporting advanced security capabilities through Amazon ECS Anywhere.\nAWS Fargate is a Serverless service, pay-as-you-go, that allows you to build applications without worrying about infrastructure. By delegating server management, resource allocation, and scaling to AWS, this helps enhance operational capabilities, accelerate the process of bringing ideas to production, and optimize TCO (Total Cost of Ownership).\nWhat will you learn through this workshop? Understand the fundamental concepts of Amazon ECS and AWS Fargate: cluster, task, and service. Deploy autoscaling for workloads to meet changing load levels. Monitor workload behavior through logs, metrics, and traces. Understand networking in AWS Fargate and advanced networking concepts. Explore security aspects, including secure credential and secret management. Learn different workload deployment strategies on Amazon ECS. Target Audience Workshop at 200+ level, suitable for those who want to get hands-on with Amazon ECS, familiarize themselves with ECS core components, as well as practical applications in deploying and managing containerized workloads. Pre-requisites This is not an introductory container workshop. Participants need foundational knowledge about Containers, specifically:\nUnderstanding of Containers, including the ability to build containers using Dockerfile. Basic knowledge and familiarity with AWS Management Console, AWS APIs. Main Content Introduction Preparation Express Mode Managed Instances Auto Scaling Networking Observability Security Deployments Storage Cost Optimizations Clean Up "
},
{
	"uri": "//localhost:1313/2-fundamentals/2.1-ecs_cluster/",
	"title": "Amazon ECS Cluster",
	"tags": [],
	"description": "",
	"content": "Amazon ECS Cluster ECS Cluster is a container runtime environment, a logical group for managing compute resources.\nInside an ECS Cluster there will be EC2 instances or Fargate capacity to run containers.\nAll Tasks and Services will be managed by the ECS Cluster.\nA Cluster is NOT a machine, it is just a management area.\nComparison of 2 Launch Type options in ECS: ECS on EC2 ECS on Fargate You manage servers ✔ ✗ Control instance type ✔ ✗ Pay per instance ✔ ✗ Serverless ✗ ✔ Suitable for large, stable workloads microservices, startups "
},
{
	"uri": "//localhost:1313/2-fundamentals/2.2-ecs_service/",
	"title": "Amazon ECS Service",
	"tags": [],
	"description": "",
	"content": "Amazon ECS Service ECS Service is a management tool that allows you to run and maintain a specific number of tasks continuously in an ECS cluster. It is an essential part of ECS for long-running applications, unlike standalone tasks used for short-term batch jobs.\nIf one of the tasks fails or stops, the ECS Service Scheduler will launch another instance of the Task Definition to replace it.\nThis helps maintain the correct desired number of tasks for the service.\nAdditionally, only Services can be configured with a Load Balancer. If you need to distribute traffic to containers, you must use a Service, not a standalone Task. LB helps with:\nHigh availability Scale Health check When to Use Service Scheduler? AWS recommends using Service Scheduler for:\nServices Stateless applications Long-running workloads Service Scheduler ensures:\nYour configured scheduling strategy is followed Tasks are rescheduled when they fail Example: If the underlying infrastructure encounters an issue, the Service Scheduler will restart the task.\nECS Service Configuration Components Service Name: Name of the service to identify it in the cluster\nTask Definition: Which Task Definition will be used to launch tasks. The Service will reference this Task Definition.\nDesired Count: Number of tasks you want the Service to keep running continuously. If you specify desired count as 3, the Service will always try to maintain 3 running tasks. If a task stops, the Service will launch a new task to replace it.​\nScheduling Strategy: There are two options:\nREPLICA: Service runs a desired number of tasks\nDAEMON: Service runs one task on each container instance in the cluster (no desired count)​\nDeployment Type: How new versions are deployed:​\nECS: Use ECS Scheduler (default rolling update)\nCODE_DEPLOY: Use AWS CodeDeploy (supports blue-green deployments)\nEXTERNAL: Allows manual deployment through TaskSets (used with CloudFormation, Jenkins, etc.)\nLoad Balancer Configuration: If you want to distribute traffic:\nLoad Balancer Type: Application Load Balancer (ALB) or Network Load Balancer (NLB)\nTarget Group: Identifies which containers will receive traffic\nPort Mapping: Maps from load balancer port to container port\nHealth Check: Configuration to check health to determine if tasks are functioning​\nECS Service Lifecycle Service operates in the following cycle:\nInitialization: You create a Service and specify desired count (e.g., 3 tasks)\nLaunch Tasks: Service scheduler launches 3 instances of the Task Definition\nRegister with Load Balancer: If there is a load balancer, tasks are automatically registered with the target group\nContinuous Monitoring: Service continuously checks the status of tasks\nReplace Failed Tasks: If a task encounters an issue, the Service launches a new task to maintain desired count\nScale Up/Down: If auto scaling is enabled, desired count will automatically adjust based on metrics\nDeployment Configuration for Rolling Updates When you deploy a new version of the application (update Task Definition), ECS uses deployment configuration to control the process:\nMinimumHealthyPercent: Minimum percentage of tasks that must remain in RUNNING state throughout the deployment process. For example, if desired count is 4 and MinimumHealthyPercent is 50%, ECS ensures at least 2 tasks (50% of 4) are still running when deploying new versions.​\nMaximumPercent: Maximum total number of tasks that can run simultaneously throughout the deployment process, expressed as a percentage of desired count. For example, if desired count is 4 and MaximumPercent is 200%, ECS allows up to 8 tasks to run at the same time - 4 old tasks + 4 new tasks. This allows faster deployment but requires more resources.​​\nExample deployment process:\nYou have 4 tasks running version v1.\nYou update Task Definition to version v2.\nMinimumHealthyPercent: 100%\nMaximumPercent: 200%\nECS launches 4 new tasks (v2) before stopping 4 old tasks (v1).\nAt this point you have 8 tasks running simultaneously.\nThen, ECS stops the 4 old v1 tasks.\nResult: 4 v2 tasks are running.\nService Auto Scaling​ Service Auto Scaling allows ECS to automatically adjust the number of tasks based on metrics such as CPU, memory, or custom metrics. There are four types of scaling:\nTarget Tracking Scaling: Maintains a specific metric at a target level. For example, you can say \u0026ldquo;maintain CPU at 70%\u0026rdquo;. ECS will automatically add tasks when CPU exceeds 70% and remove tasks when CPU is below 70%.​\nStep Scaling: Uses CloudWatch alarms with steps. For example, when CPU \u0026gt; 80%, add 2 tasks; when CPU \u0026gt; 90%, add 4 tasks.​\nScheduled Scaling: Adjusts desired count based on a time schedule. For example, scale up at 9 AM when the company opens, scale down at 6 PM when it closes.​\nPredictive Scaling: Uses machine learning to analyze historical patterns and predict future traffic.​\nMechanism for Maintaining Desired Count It is important to understand that desired count and the actual number of running tasks may differ temporarily:\nDesired Count: Number of tasks you want the Service to maintain. It is a target value that ECS tries to achieve.​ Running Tasks: Actual number of tasks currently running. When you change desired count, ECS needs time to launch or stop tasks to match the new desired count.​ Example:\nYou set desired count = 3 Currently there is 1 task running ECS will launch 2 new tasks During the launch process, running tasks = 1 but desired count = 3 After a few seconds, running tasks = 3 (matches desired count) Deployment vs Auto Scaling​ Service Auto Scaling Min/Max is the allowed range that Service Auto Scaling can adjust desired count within.\nIf you set Min = 2 and Max = 10:\nService Auto Scaling will never let desired count go below 2\nService Auto Scaling will never let desired count exceed 10\nDeployment Configuration Min/Max Percent only applies during the deployment process (when updating Task Definition). It controls the number of tasks that can run during deployment, unrelated to normal auto scaling.\n"
},
{
	"uri": "//localhost:1313/2-fundamentals/2.3-ecs_task/",
	"title": "Amazon ECS Task",
	"tags": [],
	"description": "",
	"content": "Amazon ECS Task A Task represents a running instance of a Task Definition in an ECS cluster. A Task is the result when we launch a Task Definition at a specific time in a cluster. If we specify running 3 tasks from a Task Definition, AWS ECS will launch 3 separate instances of that Task Definition.\nTask Lifecycle When a task is launched (either as part of a service, or as a standalone task), it goes through many different states:\nPROVISIONING → PENDING → ACTIVATING → RUNNING → DEACTIVATING → STOPPING → DEPROVISIONING → STOPPED\rEach state has meaning:\nPROVISIONING: ECS is provisioning necessary resources (only with Fargate).\nPENDING: Task is waiting for resources (CPU, memory) to be allocated from the cluster.\nACTIVATING: Container is starting and health checks are occurring.\nRUNNING: Container is running normally.\nDEACTIVATING: Task is preparing to stop.\nSTOPPING: Task is being stopped.\nDEPROVISIONING: Resources are being released (only with Fargate).\nSTOPPED: Task has completely stopped.\nECS tracks two different states:\nlastStatus: Current actual status of the task.\ndesiredStatus: Target status we want the task to achieve.\nFor example, if we request to stop a task, lastStatus might be RUNNING while desiredStatus will be STOPPED.\nTask Execution Role vs Task Role There are two types of IAM roles in ECS tasks:\nTask Execution Role: is the role used by the ECS Container Agent (not the container application). It grants permissions for the ECS agent to perform actions such as:\nPull Docker images from Amazon ECR Access Secrets Manager or Parameter Store to get configuration Send logs to CloudWatch Logs Pull files from S3 to launch Task Role: is the role used by the application inside the container. It allows the application to call other AWS services such as:\nS3 (to read/write files) DynamoDB (to access database) SNS/SQS (to send messages) RDS (to access database) How ECS Places Tasks on Container Instances When we run a task on an EC2-based cluster, ECS must decide which instance it will run on. This process is called task placement, and it can be controlled using Placement Strategies and Placement Constraints.\nPlacement Strategies:\nspread: Distributes tasks across multiple instances based on an attribute (e.g., ecs.availability-zone, ecs.instance-type). Good for high availability\nbinpack: Packs tasks into the fewest instances possible to save costs\nrandom: Places tasks randomly (rarely used)\nPlacement Constraints:\ndistinctInstance: Ensures each task runs on a different instance\nmemberOf: Only places tasks on instances with specific attributes/tags\nTasks - Standalone vs Service Standalone Task: Used for short-term jobs (batch jobs, one-off tasks). The task will run until it completes or encounters an error, then stops. No automatic restart mechanism.\nService Task: Used for long-running applications. The Service scheduler automatically maintains the desired number of tasks by restarting any stopped tasks.\n"
},
{
	"uri": "//localhost:1313/2-fundamentals/2.4-ecs_task_definition/",
	"title": "Amazon ECS Task Definition",
	"tags": [],
	"description": "",
	"content": "Amazon ECS Task Definition A Task Definition is a JSON blueprint describing how one or more Docker containers will run in AWS ECS. It is like a recipe or template containing all the necessary configurations to launch containers, including Docker image, CPU, memory, port mappings, environment variables, logging, and more.\nMain Components of Task Definition Task Definition is divided into two levels of configuration: Task-level parameters and Container definitions.\nTask-Level Parameters\nFamily: Name of the Task Definition family. This is the name used to identify the task definition. For example: \u0026ldquo;my-web-app\u0026rdquo;, \u0026ldquo;data-processor\u0026rdquo;. When updating a task definition, a new revision is created but the family name remains the same.​\nTask Size (CPU \u0026amp; Memory): Total amount of CPU and memory allocated for the entire task. This is different from CPU/memory at the container level. With Fargate, these values are required and must be specific supported values (e.g., 0.25 vCPU with 0.5GB-1GB memory). With EC2, these values are optional.​\nNetwork Mode: How containers will connect to the network:​\nawsvpc: Each task receives its own Elastic Network Interface (ENI) with a private IP address from the VPC. This allows the task to operate like an EC2 instance in the VPC. This is the only mode supported by Fargate and recommended for EC2.​\nbridge: Containers connect through Docker bridge network. Containers on the same host can communicate with each other. Port mapping is used to expose ports.​\nhost: Containers share the network namespace with the host. Container ports are mapped directly to host ports. Not recommended as it reduces isolation.\nnone: Containers have no network connectivity.​\nLaunch Type: Where the task will run:\nEC2: Task runs on EC2 instances managed by you.\nFargate: AWS manages infrastructure, you only need to define requirements\nExecution Role (Task Execution Role ARN): IAM role for the ECS Container Agent. This role allows the agent to pull Docker images from ECR, push logs to CloudWatch, get secrets from Secrets Manager.​\nTask Role: IAM role for the application inside the container. This role grants permissions for code to access AWS services such as S3, DynamoDB, SNS, etc.​\nPlatform: CPU architecture type (x86_64 or ARM64). With ARM64, you can use AWS Graviton processors which are more cost-effective.​\nContainer Definitions\nA Task Definition can contain one or more container definitions. Each container definition describes a separate container that will run as part of the task.\nName: Name of the container (e.g., web-server, database-client). Required.​\nImage: Docker image URI to use. Can be from Docker Hub (e.g., nginx:latest) or from Amazon ECR (e.g., 123456789012.dkr.ecr.us-east-1.amazonaws.com/my-app:1.0.0). Required.​\nCPU: Number of CPU units allocated to this container. 1 vCPU = 1024 CPU units. If task size is 1 vCPU and there are 2 containers, you can allocate 512 units to each container. If set to 0, the container will use remaining CPU units not allocated to other containers.​\nMemory: Memory in MB. It can be:\nhard limit (memory): Maximum memory the container can use. If exceeded, the container is stopped.\nsoft limit (memoryReservation): Memory guaranteed to be available for the container.​\nPort Mappings: Maps container ports to host ports. For example: containerPort 8080 → hostPort 0 means the container runs on port 8080, but exposes through dynamic port mapping on the host.​\nEssential: Boolean flag. If true, if this container fails, the entire task will be stopped. At least one container must have essential=true. If false, the task will continue running even if this container stops.​\nEnvironment Variables: Environment variables passed to the container. For example: SERVER_PORT=8080, DATABASE_HOST=db.example.com.​\nLogging Configuration: How logs will be written. Options include:\nawslogs: Logs pushed to AWS CloudWatch\nsplunk: Logs pushed to Splunk\ndatadog: Logs pushed to Datadog\nawsfirelens: Use Fluent Bit or Fluentd\nExample CloudWatch configuration:\n\u0026#34;logConfiguration\u0026#34;: { \u0026#34;logDriver\u0026#34;: \u0026#34;awslogs\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;awslogs-group\u0026#34;: \u0026#34;/ecs/my-task\u0026#34;, \u0026#34;awslogs-region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;awslogs-stream-prefix\u0026#34;: \u0026#34;ecs\u0026#34; } } Mount Points: Maps volumes into containers. Includes:\nsourceVolume: Name of the volume defined at task-level\ncontainerPath: Path inside the container where the volume is mounted (e.g., /data)\nreadOnly: Whether it is read-only​\nHealth Check: Configuration to check container health:\n\u0026#34;healthCheck\u0026#34;: { \u0026#34;command\u0026#34;: [\u0026#34;CMD-SHELL\u0026#34;, \u0026#34;curl -f http://localhost:8080/health || exit 1\u0026#34;], \u0026#34;interval\u0026#34;: 30, \u0026#34;timeout\u0026#34;: 5, \u0026#34;retries\u0026#34;: 3, \u0026#34;startPeriod\u0026#34;: 0 } Volumes (Data Storage)​\nVolumes: Volumes are defined at task-level but are mounted into containers through mount points. Volume types include:\nEBS Volumes: Amazon Elastic Block Store volumes for persistent storage (EC2 only)\nEFS Volumes: Amazon Elastic File System for shared persistent storage between multiple tasks/instances\nFSx Volumes: FSx for Windows File Server volumes\nBind Mounts: Mount a path from the host EC2 instance into the container\nDocker Volumes: Docker-managed volumes\nExample volume definition:\n\u0026#34;volumes\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;my-efs\u0026#34;, \u0026#34;efsVolumeConfiguration\u0026#34;: { \u0026#34;fileSystemId\u0026#34;: \u0026#34;fs-1234567\u0026#34;, \u0026#34;transitEncryption\u0026#34;: \u0026#34;ENABLED\u0026#34; } }, { \u0026#34;name\u0026#34;: \u0026#34;my-bind-volume\u0026#34;, \u0026#34;host\u0026#34;: { \u0026#34;sourcePath\u0026#34;: \u0026#34;/mnt/data\u0026#34; } } ] Versioning and Revisions​\nTask Definitions are immutable. This means you cannot edit an existing task definition. Instead, you must create a new revision.​\nA revision is a copy of the current task definition with changes applied. Each task definition family can have multiple revisions:\nmy-app:1 (revision 1).\nmy-app:2 (revision 2).\nmy-app:3 (revision 3).\nWhen updating a service or running a task, specify family:revision to use (e.g., \u0026ldquo;my-app:3\u0026rdquo;). This allows easy rollback to an old revision if there is an issue by simply updating the service to use the previous revision.​\nAdvantages of this architecture:\nAudit trail: Can view all changes that have been made.\nEasy rollback: Roll back to an old revision if needed.\nVersion control: Like version control for infrastructure.\nTask Definition JSON\n{ \u0026#34;family\u0026#34;: \u0026#34;my-web-app\u0026#34;, \u0026#34;cpu\u0026#34;: \u0026#34;256\u0026#34;, \u0026#34;memory\u0026#34;: \u0026#34;512\u0026#34;, \u0026#34;networkMode\u0026#34;: \u0026#34;awsvpc\u0026#34;, \u0026#34;requiresCompatibilities\u0026#34;: [\u0026#34;FARGATE\u0026#34;], \u0026#34;executionRoleArn\u0026#34;: \u0026#34;arn:aws:iam::123456789012:role/ecsTaskExecutionRole\u0026#34;, \u0026#34;taskRoleArn\u0026#34;: \u0026#34;arn:aws:iam::123456789012:role/ecsTaskRole\u0026#34;, \u0026#34;containerDefinitions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;web-server\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;123456789012.dkr.ecr.us-east-1.amazonaws.com/my-app:1.0.0\u0026#34;, \u0026#34;cpu\u0026#34;: 256, \u0026#34;memory\u0026#34;: 512, \u0026#34;essential\u0026#34;: true, \u0026#34;portMappings\u0026#34;: [ { \u0026#34;containerPort\u0026#34;: 8080, \u0026#34;hostPort\u0026#34;: 8080, \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34; } ], \u0026#34;logConfiguration\u0026#34;: { \u0026#34;logDriver\u0026#34;: \u0026#34;awslogs\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;awslogs-group\u0026#34;: \u0026#34;/ecs/my-web-app\u0026#34;, \u0026#34;awslogs-region\u0026#34;: \u0026#34;us-east-1\u0026#34;, \u0026#34;awslogs-stream-prefix\u0026#34;: \u0026#34;ecs\u0026#34; } }, \u0026#34;environment\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;ENVIRONMENT\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;production\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;DATABASE_HOST\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;db.example.com\u0026#34; } ] } ] } "
},
{
	"uri": "//localhost:1313/3-prepare/3.2-cluster-task_definitions/",
	"title": "Create Cluster &amp; Task Definition",
	"tags": [],
	"description": "",
	"content": "Create Cluster Create an Amazon ECS Cluster named retail-store-ecs-cluster with CloudWatch Container Insights.\nContainer Insights collects, aggregates, and summarizes metrics and logs from containerized applications.\naws ecs create-cluster --cluster-name retail-store-ecs-cluster --capacity-providers FARGATE FARGATE_SPOT --default-capacity-provider-strategy capacityProvider=FARGATE,weight=1 --settings name=containerInsights,value=enhanced After running the command, you will get the following result and can see that CloudWatch Container Insights has been configured successfully.\n{ \u0026#34;cluster\u0026#34;: { \u0026#34;clusterArn\u0026#34;: \u0026#34;arn:aws:ecs:ap-northeast-2:111111111111:cluster/retail-store-ecs-cluster\u0026#34;, \u0026#34;clusterName\u0026#34;: \u0026#34;retail-store-ecs-cluster\u0026#34;, \u0026#34;status\u0026#34;: \u0026#34;ACTIVE\u0026#34;, \u0026#34;registeredContainerInstancesCount\u0026#34;: 0, \u0026#34;runningTasksCount\u0026#34;: 0, \u0026#34;pendingTasksCount\u0026#34;: 0, \u0026#34;activeServicesCount\u0026#34;: 0, \u0026#34;statistics\u0026#34;: [], \u0026#34;tags\u0026#34;: [], \u0026#34;settings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;containerInsights\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;enhanced\u0026#34; } ], \u0026#34;capacityProviders\u0026#34;: [], \u0026#34;defaultCapacityProviderStrategy\u0026#34;: [] } } Check the AWS Console to confirm the cluster has been created successfully.\nCreate Roles Create two IAM Roles required for ECS Tasks:\nretailStoreEcsTaskExecutionRole: allows ECS to pull images, write logs, and access secrets.\nretailStoreEcsTaskRole: grants permissions to the application inside the container.\naws iam create-role --role-name retailStoreEcsTaskExecutionRole --assume-role-policy-document file://ecs-task-trust.json Content of the ecs-task-trust.json file:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;ecs-tasks.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } Attach permissions to retailStoreEcsTaskExecutionRole:\naws iam attach-role-policy --role-name retailStoreEcsTaskExecutionRole --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy Create retailStoreEcsTaskRole:\naws iam create-role --role-name retailStoreEcsTaskRole --assume-role-policy-document file://ecs-task-trust.json Create Task Definition Create a Task Definition named retail-store-ecs-ui to be used for the UI Service with the following configuration:\n{ \u0026#34;family\u0026#34;: \u0026#34;retail-store-ecs-ui\u0026#34;, \u0026#34;networkMode\u0026#34;: \u0026#34;awsvpc\u0026#34;, \u0026#34;requiresCompatibilities\u0026#34;: [ \u0026#34;FARGATE\u0026#34; ], \u0026#34;cpu\u0026#34;: \u0026#34;1024\u0026#34;, \u0026#34;memory\u0026#34;: \u0026#34;2048\u0026#34;, \u0026#34;runtimePlatform\u0026#34;: { \u0026#34;cpuArchitecture\u0026#34;: \u0026#34;X86_64\u0026#34;, \u0026#34;operatingSystemFamily\u0026#34;: \u0026#34;LINUX\u0026#34; }, \u0026#34;containerDefinitions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;public.ecr.aws/aws-containers/retail-store-sample-ui:1.2.3\u0026#34;, \u0026#34;portMappings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;containerPort\u0026#34;: 8080, \u0026#34;hostPort\u0026#34;: 8080, \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;appProtocol\u0026#34;: \u0026#34;http\u0026#34; } ], \u0026#34;essential\u0026#34;: true, \u0026#34;linuxParameters\u0026#34;: { \u0026#34;initProcessEnabled\u0026#34;: true }, \u0026#34;healthCheck\u0026#34;: { \u0026#34;command\u0026#34;: [ \u0026#34;CMD-SHELL\u0026#34;, \u0026#34;curl -f http://localhost:8080/actuator/health || exit 1\u0026#34; ], \u0026#34;interval\u0026#34;: 10, \u0026#34;timeout\u0026#34;: 5, \u0026#34;retries\u0026#34;: 3, \u0026#34;startPeriod\u0026#34;: 60 }, \u0026#34;logConfiguration\u0026#34;: { \u0026#34;logDriver\u0026#34;: \u0026#34;awslogs\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;awslogs-group\u0026#34;: \u0026#34;retail-store-ecs-tasks\u0026#34;, \u0026#34;awslogs-region\u0026#34;: \u0026#34;$AWS_REGION\u0026#34;, \u0026#34;awslogs-stream-prefix\u0026#34;: \u0026#34;ui-service\u0026#34; } } } ], \u0026#34;executionRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/retailStoreEcsTaskExecutionRole\u0026#34;, \u0026#34;taskRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/retailStoreEcsTaskRole\u0026#34; } Note that ACCOUNT_ID is your AWS account ID, and AWS_REGION is your region.\nCreate a JSON file with the above content and name it retail-store-ecs-ui-taskdef.json.\nRun the following command to create the Task Definition.\naws ecs register-task-definition --cli-input-json file://retail-store-ecs-ui-taskdef.json Check the AWS Console to confirm the Task Definition has been created successfully.\nYou can retrieve the successfully created Task Definition by running the following command:\naws ecs describe-task-definition --task-definition retail-store-ecs-ui "
},
{
	"uri": "//localhost:1313/2-fundamentals/",
	"title": "Fundamentals",
	"tags": [],
	"description": "",
	"content": "Amazon ECS Core Components Amazon ECS has 4 main components:\nCluster: The central management space in Amazon ECS, where all application services and tasks are organized and operated.\nService: Represents a group of identical tasks, responsible for maintaining the desired number of tasks running, while supporting automatic restart or scaling when needed.\nTask: The execution unit in ECS, consisting of one or more containers working together to perform a specific application function.\nTask Definition: A detailed description of how a task is run, including information such as CPU, memory, container image, network configuration, IAM role, and other necessary settings.\nUnderstanding these components is very important for using Amazon ECS effectively in managing containerized applications. Each component plays a key role in the overall architecture and operation of ECS deployments.\nLayers There are 3 Layers in ECS:\nCapacity: Infrastructure where containers run.\nController: Deploy and manage applications running on containers.\nProvisioning: Tools to interact with the scheduler to deploy and manage applications and containers.\nCapacity Capacity (compute capacity) is the infrastructure where containers run. Below is an overview of capacity options:\nAmazon ECS Managed Instances Amazon ECS Managed Instances is a compute option for Amazon ECS, allowing you to run containerized workloads on various Amazon EC2 instance types, while transferring most infrastructure management to AWS.\nWith Amazon ECS Managed Instances, you can:\nGPU acceleration. Specific CPU architecture. High network performance. Dedicated instance types. Meanwhile, AWS will be responsible for:\nInfrastructure provisioning. Operating system patching. Scaling. Maintenance and operation of underlying infrastructure. Amazon EC2 Instances You can choose the instance type and number of instances yourself. Manage capacity yourself (Auto Scaling, patching, lifecycle, etc.). Serverless AWS Fargate is a serverless compute engine, pay-as-you-go. With Fargate: No need to manage servers. No need to plan capacity. No need to isolate container workloads yourself as AWS handles security. Server/VM On-Premises Amazon ECS Anywhere registers external instances (on-premises servers or VMs). Connect them to an ECS cluster. Amazon ECS Scheduler Amazon ECS Scheduler is software responsible for managing and orchestrating your applications, including: Deciding where tasks run. Managing task lifecycle. Ensuring service desired state. "
},
{
	"uri": "//localhost:1313/4-express-mode/4.1-setup_deploy/",
	"title": "Express Mode",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/4-express-mode/4.2-update/",
	"title": "Express Mode",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/4-express-mode/",
	"title": "Express Mode",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/3-prepare/",
	"title": "Prepare",
	"tags": [],
	"description": "",
	"content": "In this section, you will perform the necessary preparation steps to be ready for the following practice sections. These preparation steps will help you set up the environment and basic configuration to deploy and manage containerized applications on Amazon ECS.\nIn this Prepare section, you will:\n3.1 - Create User \u0026amp; Access Key\nInstall and configure AWS CLI Create IAM User with AdministratorAccess permissions Create Access Key to authenticate with AWS services 3.2 - Create Cluster \u0026amp; Task Definition\nCreate Amazon ECS Cluster with CloudWatch Container Insights Define Task Definitions with CPU, memory, and container specifications 3.3 - Services\nCreate VPC and configure networking (subnets, NAT Gateway) Deploy and manage ECS Services to maintain desired task counts 3.4 - Update Services\nUpdate services with new configurations and deployments Use environment variables to configure the application "
},
{
	"uri": "//localhost:1313/3-prepare/3.3-services/",
	"title": "Services",
	"tags": [],
	"description": "",
	"content": "Create VPC Access VPC on AWS Console:\nSelect Create VPC.\nSelect VPC and more and configure the following parameters:\nVPC Name: ecs-workshop VPC CIDR Block: 10.0.0.0/16 Number of Availability Zones: 2 Number of Public Subnets: 2 Number of Private Subnets: 2 NAT Gateway: None (NAT will be created manually later) VPC Endpoint: None After configuration is complete, select Create VPC.\nThe VPC has been created successfully.\nCreate NAT Gateway On the VPC Console interface, select NAT Gateways and select Create NAT Gateway.\nConfigure the following parameters:\nNAT Gateway Name: ecs-workshop-nat Availability mode: Regional VPC: The VPC you just created. Method of Elastic IP (EIP) allocation: Automatic After configuration is complete, select Create NAT Gateway\nCreate an Elastic IP on the VPC Console interface.\nSelect Allocate Elastic IP address Select Allocate\nThe Elastic IP has been created successfully.\nThe NAT Gateway will automatically use the created Elastic IP.\nAfter creating the NAT Gateway, configure the Route Table for the Private Subnet.\nAccess Route Table:\nSelect Private Subnet. Select Routes Select Edit Routes Configure the following parameters:\nDestination: 0.0.0.0/0 Target: NAT Gateway and select the ID of the NAT Gateway you just created. The Route Table has been configured successfully.\nDo the same for the second Private Subnet.\nCreate Security Group Access the EC2 Console:\nSelect Security Groups and select Create Security Group.\nWe will create alb-sg to allow access to the ALB.\nSecurity Group Name: alb-sg Description: Security Group for ALB VPC: The VPC you just created. Inbound rules:\nType: HTTP Port: 80 Source: 0.0.0.0/0 Type: HTTPS Port: 443 Source: 0.0.0.0/0 Outbound rules:\nType: All traffic Source: 0.0.0.0/0 After configuration is complete, select Create Security Group\nAfter creating the Security Group for the ALB, create a Security Group for the application.\nSecurity Group Name: ui-sg Description: Security Group for UI VPC: The VPC you just created. Inbound rules:\nType: Custom TCP Rule Port: 8080 Source: alb-sg After configuration is complete, select Create Security Group\nThe Security Group has been created successfully.\nCreate Target Group Access the EC2 Console:\nSelect Target Groups and select Create Target Group.\nConfigure the following parameters:\nTarget Group Name: ui-tg Target Type: IP Addresses Protocol: HTTP Port: 8080 VPC: The VPC you just created. Health Check Protocol: HTTP Health Check Path: /actuator/health After configuration is complete, select Next.\nSelect Next.\nReview the parameters and select Create Target Group.\nThe Target Group has been created successfully.\nCreate Application Load Balancer On the EC2 Console interface, select Load Balancers and select Create Load Balancer.\nSelect Type as Application Load Balancer.\nConfigure the following parameters:\nLoad Balancer Name: ecs-workshop-alb Scheme: Internet-facing VPC: The VPC you just created. Configure 2 Public Subnets for the ALB. Select the alb-sg you just created. Review and select Create Load Balancer.\nCreate ECS Service After creating the above components, create the ECS Service.\nUse the following CLI to create the ECS Service.\nNote the following parameters:\nUI_TG_ARN: ARN of the application\u0026rsquo;s Target Group. PRIVATE_SUBNET1: ID of the first Private Subnet. PRIVATE_SUBNET2: ID of the second Private Subnet. UI_SG_ID: ID of the application\u0026rsquo;s Security Group. aws ecs create-service \\ --cluster retail-store-ecs-cluster \\ --service-name ui \\ --task-definition retail-store-ecs-ui \\ --desired-count 2 \\ --launch-type FARGATE \\ --load-balancers targetGroupArn=${UI_TG_ARN},containerName=application,containerPort=8080 \\ --network-configuration \u0026#34;awsvpcConfiguration={subnets=[${PRIVATE_SUBNET1},${PRIVATE_SUBNET2}],securityGroups=[${UI_SG_ID}],assignPublicIp=DISABLED}\u0026#34; Access the Cluster to check and you can see the Service has been created successfully.\nCheck Service information:\nCheck Task information:\nWe can see that 2 Tasks have been created successfully.\nAccess the web using the ALB URL to check the website.\nhttp://ecs-workshop-alb-653740503.ap-northeast-2.elb.amazonaws.com\nThe application has been deployed successfully.\nAfter creating the basic components, the current architecture of the configured Services is shown below.\n"
},
{
	"uri": "//localhost:1313/5-managed-instances/5.1-enable/",
	"title": "Managed Instances",
	"tags": [],
	"description": "",
	"content": "Managed Instances "
},
{
	"uri": "//localhost:1313/5-managed-instances/",
	"title": "Managed Instances",
	"tags": [],
	"description": "",
	"content": "Managed Instances "
},
{
	"uri": "//localhost:1313/3-prepare/3.4-updated_services/",
	"title": "Update Services",
	"tags": [],
	"description": "",
	"content": "In this section, we will update an ECS Service. This process is commonly used in scenarios such as changing container images or adjusting application configurations.\nEnvironment variables are one of the main mechanisms for configuring workloads running in containers, regardless of which Orchestrator is used. We will change the configuration of the UI Service to use new environment variables.\nDocker Images cannot be changed after being built, so environment variables are a simple and flexible way to configure and adjust application behavior when containers are running.\nIn this case, we will use the RETAIL_UI_THEME variable, which will change the default interface color of the application.\nDeclare variables in Task Definition Environment variables in ECS task definitions are declared as name-value pairs, for example:\n\u0026#34;environment\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_UI_THEME\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;green\u0026#34; } ] Next, we will update the retail-store-ecs-ui-updated-taskdef.json file with the new environment variable.\n{ \u0026#34;family\u0026#34;: \u0026#34;retail-store-ecs-ui\u0026#34;, \u0026#34;executionRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/retailStoreEcsTaskExecutionRole\u0026#34;, \u0026#34;taskRoleArn\u0026#34;: \u0026#34;arn:aws:iam::${ACCOUNT_ID}:role/retailStoreEcsTaskRole\u0026#34;, \u0026#34;networkMode\u0026#34;: \u0026#34;awsvpc\u0026#34;, \u0026#34;requiresCompatibilities\u0026#34;: [ \u0026#34;FARGATE\u0026#34; ], \u0026#34;cpu\u0026#34;: \u0026#34;1024\u0026#34;, \u0026#34;memory\u0026#34;: \u0026#34;2048\u0026#34;, \u0026#34;runtimePlatform\u0026#34;: { \u0026#34;cpuArchitecture\u0026#34;: \u0026#34;X86_64\u0026#34;, \u0026#34;operatingSystemFamily\u0026#34;: \u0026#34;LINUX\u0026#34; }, \u0026#34;containerDefinitions\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;image\u0026#34;: \u0026#34;public.ecr.aws/aws-containers/retail-store-sample-ui:1.2.3\u0026#34;, \u0026#34;portMappings\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;application\u0026#34;, \u0026#34;containerPort\u0026#34;: 8080, \u0026#34;hostPort\u0026#34;: 8080, \u0026#34;protocol\u0026#34;: \u0026#34;tcp\u0026#34;, \u0026#34;appProtocol\u0026#34;: \u0026#34;http\u0026#34; } ], \u0026#34;essential\u0026#34;: true, \u0026#34;linuxParameters\u0026#34;: { \u0026#34;initProcessEnabled\u0026#34;: true }, \u0026#34;environment\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;RETAIL_UI_THEME\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;green\u0026#34; } ], \u0026#34;healthCheck\u0026#34;: { \u0026#34;command\u0026#34;: [ \u0026#34;CMD-SHELL\u0026#34;, \u0026#34;curl -f http://localhost:8080/actuator/health || exit 1\u0026#34; ], \u0026#34;interval\u0026#34;: 10, \u0026#34;timeout\u0026#34;: 5, \u0026#34;retries\u0026#34;: 3, \u0026#34;startPeriod\u0026#34;: 60 }, \u0026#34;logConfiguration\u0026#34;: { \u0026#34;logDriver\u0026#34;: \u0026#34;awslogs\u0026#34;, \u0026#34;options\u0026#34;: { \u0026#34;awslogs-group\u0026#34;: \u0026#34;retail-store-ecs-tasks\u0026#34;, \u0026#34;awslogs-region\u0026#34;: \u0026#34;$AWS_REGION\u0026#34;, \u0026#34;awslogs-stream-prefix\u0026#34;: \u0026#34;ui-service\u0026#34; } } } ] } Then, use the register-task-definition command to register the new task definition:\naws ecs register-task-definition \\ --cli-input-json file://retail-store-ecs-ui-updated-taskdef.json ECS task definitions are immutable, meaning they cannot be edited after creation. Instead, the above command will create a new revision, which is a copy of the old task definition but with updated parameters.\nCheck Task Definition revisions You can check how many revisions currently exist using the command:\naws ecs list-task-definitions --family-prefix retail-store-ecs-ui --sort DESC --max-items 2 The result will display the revisions of the UI task definition:\n{ \u0026#34;taskDefinitionArns\u0026#34;: [ \u0026#34;arn:aws:ecs:us-west-2:XXXXXXXXXXXX:task-definition/retail-store-ecs-ui:2\u0026#34;, \u0026#34;arn:aws:ecs:us-west-2:XXXXXXXXXXXX:task-definition/retail-store-ecs-ui:1\u0026#34; ] } Or you can check directly on the AWS Console:\nUpdate ECS Service to use the new revision Next, update the ECS service to use the new task definition:\naws ecs update-service --cluster retail-store-ecs-cluster --service ui --task-definition retail-store-ecs-ui Check the results "
},
{
	"uri": "//localhost:1313/6-auto-scaling/",
	"title": "Auto Scaling",
	"tags": [],
	"description": "",
	"content": "Auto Scaling "
},
{
	"uri": "//localhost:1313/3-prepare/3.5-enable_ecs_exec/",
	"title": "Enable ECS Exec",
	"tags": [],
	"description": "",
	"content": "In this section, we will enable the ECS Exec feature to run commands or open a shell directly into a container running on an EC2 instance or Fargate.\nEnabling ECS Exec brings many benefits for operational management and is particularly good for security. This feature allows controlled access to containers running in ECS tasks, enabling safe, auditable troubleshooting without needing SSH access to the host.\nBy leveraging IAM policies and IAM roles, you can tightly control who is allowed to execute commands inside containers, thereby enhancing the overall security posture of the system.\nAdditionally, all commands executed through ECS Exec are logged to CloudWatch, helping to create an audit trail for monitoring and compliance purposes.\nSet IAM Role for User This is a step to set up permissions for the User to use ECS Exec. If following this lab, we have already configured the User with AdministratorAccess permissions, so this step can be skipped.\nWe will use ECS Exec from the IDE, so ensure that the IAM role attached to the IDE has all necessary permissions.\nUpdate the IAM role attached to the EC2 instance running the IDE by adding the following inline policy:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;ecs:ExecuteCommand\u0026#34;, \u0026#34;ecs:DescribeTasks\u0026#34; ], \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:ecs:${AWS_REGION}:${ACCOUNT_ID}:task/retail-store-ecs-cluster/*\u0026#34;, \u0026#34;arn:aws:ecs:${AWS_REGION}:${ACCOUNT_ID}:cluster/*\u0026#34; ] } ] } Add the above JSON to the ecs-exec-command-policy.json file and run the following command:\naws iam put-role-policy --role-name $(aws sts get-caller-identity --query \u0026#39;Arn\u0026#39; | cut -d\u0026#39;/\u0026#39; -f2) --policy-name AmazonECSExecCommand --policy-document file://ecs-exec-command-policy.json Set IAM Role for ECS Task Role ECS Exec requires a task IAM role to communicate with AWS Systems Manager (SSM).\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;ssmmessages:CreateControlChannel\u0026#34;, \u0026#34;ssmmessages:CreateDataChannel\u0026#34;, \u0026#34;ssmmessages:OpenControlChannel\u0026#34;, \u0026#34;ssmmessages:OpenDataChannel\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Add the above JSON to the ecs-exec-task-role-policy.json file and run the following command:\naws iam put-role-policy --role-name retailStoreEcsTaskRole --policy-name AmazonECSExecTaskRolePolicy --policy-document file://ecs-exec-task-role-policy.json Check the Policy of the role you just created\naws iam list-role-policies --role-name retailStoreEcsTaskRole --query \u0026#39;PolicyNames[0]\u0026#39; --output text Check the role permissions using the following command:\naws iam get-role-policy --role-name retailStoreEcsTaskRole --policy-name AmazonECSExecTaskRolePolicy Prepare environment Install the necessary tools:\nAWS CLI. Session Manager plugin for AWS CLI. We have already installed AWS CLI in the Create User and Access Key section. Next, we will install the Session Manager plugin for AWS CLI.\nLinux: curl \u0026#34;https://s3.amazonaws.com/session-manager-downloads/plugin/latest/ubuntu_64bit/session-manager-plugin.deb\u0026#34; -o \u0026#34;session-manager-plugin.deb\u0026#34; sudo dpkg -i session-manager-plugin.deb MacOS: curl \u0026#34;https://s3.amazonaws.com/session-manager-downloads/plugin/latest/mac/session-manager-plugin.pkg\u0026#34; -o \u0026#34;session-manager-plugin.pkg\u0026#34; sudo installer -pkg session-manager-plugin.pkg -target / sudo ln -s /usr/local/sessionmanagerplugin/bin/session-manager-plugin /usr/local/bin/session-manager-plugin Windows: https://s3.amazonaws.com/session-manager-downloads/plugin/latest/windows/SessionManagerPluginSetup.exe Run the following command to verify that the Session Manager plugin has been installed successfully:\nsession-manager-plugin Enable ECS Exec on Service Update the UI Service to enable ECS Exec by using the --enable-execute-command flag:\naws ecs update-service \\ --cluster retail-store-ecs-cluster \\ --service ui \\ --task-definition retail-store-ecs-ui \\ --enable-execute-command --force-new-deployment Check ARN of ECS task with ECS Exec enabled Run the following command to select a running UI task that has enableExecuteCommand = true:\nECS_EXEC_TASK_ARN=$(aws ecs list-tasks --cluster retail-store-ecs-cluster \\ --service-name ui --query \u0026#39;taskArns[]\u0026#39; --output text | \\ xargs -n1 aws ecs describe-tasks --cluster retail-store-ecs-cluster --tasks | \\ jq -r \u0026#39;.tasks[] | select(.enableExecuteCommand == true) | .taskArn\u0026#39; | \\ head -n 1) Check the result by running the echo command:\necho $ECS_EXEC_TASK_ARN Connect to ECS Task Connect to the ECS Task by running the following command:\nif [ -z \u0026#34;${ECS_EXEC_TASK_ARN}\u0026#34; ]; then echo \u0026#34;ECS_EXEC_TASK_ARN is not correctly configured!\u0026#34; else aws ecs execute-command \\ --cluster retail-store-ecs-cluster \\ --task $ECS_EXEC_TASK_ARN \\ --container application \\ --interactive \\ --command \u0026#34;/bin/bash\u0026#34; fi We will see the Output as below:\nThe Session Manager plugin was installed successfully. Use the AWS CLI to start a session. Starting session with SessionId: ecs-execute-command-vvdysulqbcz2txr2d262sw2s64 bash-5.2# "
},
{
	"uri": "//localhost:1313/7-networking/",
	"title": "Networking",
	"tags": [],
	"description": "",
	"content": "Networking "
},
{
	"uri": "//localhost:1313/8-observability/",
	"title": "Observability",
	"tags": [],
	"description": "",
	"content": "Observability "
},
{
	"uri": "//localhost:1313/9-security/",
	"title": "Security",
	"tags": [],
	"description": "",
	"content": "Security "
},
{
	"uri": "//localhost:1313/10-deployments/",
	"title": "Deployments",
	"tags": [],
	"description": "",
	"content": "Deployments "
},
{
	"uri": "//localhost:1313/11-storage/",
	"title": "Storage",
	"tags": [],
	"description": "",
	"content": "Storage "
},
{
	"uri": "//localhost:1313/12-cost-optimizations/",
	"title": "Cost Optimizations",
	"tags": [],
	"description": "",
	"content": "Cost Optimizations "
},
{
	"uri": "//localhost:1313/13-clean-up/",
	"title": "Clean Up",
	"tags": [],
	"description": "",
	"content": "Clean Up "
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]